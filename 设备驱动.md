# 1.键盘驱动

## 键盘中断向量

- 0x21 键盘中断向量；
| 端口 | 操作类型 | 用途       |
| ---- | -------- | ---------- |
| 0x60 | 读/写    | 数据端口   |
| 0x64 | 读       | 状态寄存器 |
| 0x64 | 写       | 控制寄存器 |


## 定义端口

- 数据端口：`#define KEYBOARD_DATA_PORT 0x60`
- 控制端口：`#define KEYBOARD_CTRL_PORT 0x64`


## 键盘处理

```c
assert(vector == 0x21);
// 向中断控制器发送中断处理结束的信息
send_eoi(vector);

// 从键盘读取按键信息，接收扫描码
u16 scancode = inb(KEYBOARD_DATA_PORT);
// keymap 状态索引，默认没有 shift 键，可能为2可能为3
u8 ext = 2; 
```


## 初始化

```c
// 给键盘的中断处理函数赋值
set_interrupt_handler(IRQ_KEYBOARD, keyboard_handler);
// 将键盘屏蔽字打开
set_interrupt_mask(IRQ_KEYBOARD, true);
```


## 参考文献

- <https://wiki.osdev.org/PS/2_Keyboard>
- <https://wiki.osdev.org/PS/2>
- <https://wiki.osdev.org/%228042%22_PS/2_Controller>


---


# 2.键盘驱动

## 键盘扫描码

![](./images/keyboard_scancode.svg)

键盘扫描码分为：

- 通码：按下按键产生的扫描码
- 断码：抬起按键产生的扫描码


## 8042 控制器

| 端口 | 操作类型 | 用途       |
| ---- | -------- | ---------- |
| 0x60 | 读/写    | 数据端口   |
| 0x64 | 读       | 状态寄存器 |
| 0x64 | 写       | 控制寄存器 |

数据端口用于读取数据和写入数据；

状态寄存器：

0. 输出缓冲区状态：1 表示输出缓冲区满
1. 输入缓冲区状态：1 表示输入缓冲区满
2. 系统标志位：加电时置为 0，自检通过时置为 1
3. 命令/数据位：1 表示输入缓冲区的内容是命令，0 表示输入缓冲区的内容是数据
4. 1 表示键盘启用，0 表示键盘禁用
5. 1 表示发送超时
6. 1 表示接受超时
7. 奇偶校验出错


## 定义字符与按键

- 不可见字符：`#define INV 0`
- PrtSc：`#define CODE_PRINT_SCREEN_DOWN 0xB7`
- 使用 typedef enum 给按键赋值：

```c
typedef enum
{
    KEY_NONE,
    KEY_ESC,
    KEY_1,
    KEY_2,
    //......
    //......
    KEY_WIN_R,
    KEY_CLIPBOARD,
    KEY_5D,
    KEY_5E,
    // 以下为自定义按键，为和 keymap 索引匹配
    KEY_PRINT_SCREEN,
} KEY;

static char keymap[][4] = {
    /* 扫描码 未与 shift 组合  与 shift 组合 以及相关状态 */
    /* ---------------------------------- */
    /* 0x00 */ {INV, INV, false, false},   // NULL
    /* 0x01 */ {0x1b, 0x1b, false, false}, // ESC
    /* 0x02 */ {'1', '!', false, false},
    /* 0x03 */ {'2', '@', false, false},
    //......
    //......
    /* 0x5B */ {INV, INV, false, false},  // Left Windows
    /* 0x5C */ {INV, INV, false, false},  // Right Windows
    /* 0x5D */ {INV, INV, false, false},  // Clipboard
    /* 0x5E */ {INV, INV, false, false},  //

    // Print Screen 是强制定义 本身是 0xB7
    /* 0x5F */ {INV, INV, false, false}, // PrintScreen
};
```

## 用于多组合按键判断

```c
// CTRL 键状态，判断 ctrl 键有没有被按下
#define ctrl_state (keymap[KEY_CTRL_L][2] || keymap[KEY_CTRL_L][3])

// ALT 键状态，判断 ALT 键有没有被按下
#define alt_state (keymap[KEY_ALT_L][2] || keymap[KEY_ALT_L][3])

// SHIFT 键状态，判断 SHIFT 键有没有被按下
#define shift_state (keymap[KEY_SHIFT_L][2] || keymap[KEY_SHIFT_R][2])
```

## 按键处理总函数

```c
//用于判断并相应各种按键操作，包括了部分按键的LED灯
void keyboard_handler(int vector)
```

## 参考文献

- <https://www.win.tue.nl/~aeb/linux/kbd/scancodes-1.html>
- <https://wiki.osdev.org/PS/2_Keyboard>
- <https://wiki.osdev.org/PS/2>
- <https://wiki.osdev.org/%228042%22_PS/2_Controller>
- [郑刚 / 操作系统真象还原 / 人民邮电出版社 / 2016](https://book.douban.com/subject/26745156/)
- <https://www.ceibo.com/eng/datasheets/Intel-8048-8049-8050-plcc-dip.pdf>
- <http://www.mcamafia.de/pdf/pdfref.htm>
- <http://www.mcamafia.de/pdf/ibm_hitrc07.pdf>
- <https://en.wikipedia.org/wiki/Scancode>


---


# 3.键盘 LED 灯

PS/2 键盘接受很多种类型的命令，命令有一个字节，一些命令有数据必须在命令字节发送之后再发送。键盘通过一个 ACK(0xFA) (表示命令已收到) 或者 Resend(0xFE) (表示前一个命令有错误)；在发送命令之间需要等待缓冲区为空；

| 位  | 表示     |
| --- | -------- |
| 0   | 滚动锁定 |
| 1   | 数字锁定 |
| 2   | 大写锁定 |


## 定义LED灯的命令

- #define KEYBOARD_CMD_LED 0xED // 设置 LED 状态
- #define KEYBOARD_CMD_ACK 0xFA // ACK


## LED相关函数

```c
static void keyboard_wait()
{
    u8 state;
    do
    {
        state = inb(KEYBOARD_CTRL_PORT); // 读信息
    } while (state & 0x02); // 读取键盘缓冲区，直到为空，即第二位为 0
}

static void keyboard_ack()
{
    u8 state;
    do
    {
        state = inb(KEYBOARD_DATA_PORT);
    } while (state != KEYBOARD_CMD_ACK); // 等待键盘发送 ACK，表示收到了命令
}

static void set_leds()
{
    //滚动锁定：第 0 位
    //数字锁定：第 1 位
    //大写锁定：第 2 位
    u8 leds = (capslock_state << 2) | (numlock_state << 1) | scrlock_state;

    keyboard_wait(); // 等待缓冲区为空

    outb(KEYBOARD_DATA_PORT, KEYBOARD_CMD_LED); // 设置 LED 命令
    
    keyboard_ack(); //等待键盘给 ACK

    keyboard_wait(); // 等待缓冲区为空
    
    outb(KEYBOARD_DATA_PORT, leds); // 设置 LED 灯状态

    keyboard_ack(); //等待键盘给 ACK
}
```


## LED 灯初始化

```c
numlock_state = false;
scrlock_state = false;
capslock_state = false;
extcode_state = false;
```


## 参考文献

- <https://wiki.osdev.org/PS/2_Keyboard>
- <https://forum.osdev.org/viewtopic.php?t=10053>
- [赵炯 / Linux内核完全注释 / 机械工业出版社 / 2005](https://book.douban.com/subject/1231236/)


---


# 4.硬盘同步 PIO

## PIO
PIO(Programmed Input/Output) 编程输入输出，PIO 模式使用了大量的 CPU 资源，因为磁盘和 CPU 之间传输的每个字节的数据都必须通过 CPU 的 IO 端口总线(而不是内存)传送。在某些 CPU 上，PIO 模式仍然可以实现每秒 16 MB 的实际传输速度，但是机器上的其他进程将得不到任何 CPU 时间片。

不过，当计算机刚开始启动时，没有其他进程。因此，在系统进入多任务模式之前，PIO 模式是一个在启动过程中使用的优秀而简单的接口。


## 硬盘相关常量

- #define SECTOR_SIZE 512   // 扇区大小
- #define IDE_CTRL_NR 2 // 控制器数量，固定为 2
- #define IDE_DISK_NR 2 // 每个控制器可挂磁盘数量，固定为 2

## 硬盘相关数据结构

```c
// IDE 磁盘数据结构
typedef struct ide_disk_t
{
    char name[8];                  // 磁盘名称
    struct ide_ctrl_t *ctrl;       // 控制器指针
    u8 selector;                   // 磁盘选择
    bool master;                   // 主盘
    u32 total_lba;                 // 可用扇区数量
    u32 cylinders;                 // 柱面数
    u32 heads;                     // 磁头数
    u32 sectors;                   // 扇区数
    u32 interface;                 // 磁盘类型
    u32 sector_size;               // 扇区大小
    ide_part_t parts[IDE_PART_NR]; // 硬盘分区
} ide_disk_t;

// IDE 控制器数据结构
typedef struct ide_ctrl_t
{
    char name[8];                  // 控制器名称
    lock_t lock;                   // 控制器锁
    int iotype;                    // 设备 IO 类型
    u16 iobase;                    // IO 寄存器基址
    u16 bmbase;                    // PCI 总线主控寄存器基地址
    ide_disk_t disks[IDE_DISK_NR]; // 磁盘
    ide_disk_t *active;            // 当前选择的磁盘的指针
    u8 control;                    // 控制字节
    struct task_t *waiter;         // 等待控制器的进程
    ide_prd_t prd;                 // Physical Region Descriptor
} ide_ctrl_t;
```


## 硬盘相关函数

```c
// 读磁盘函数  *buf：读到buffer中  count：读多少个扇区  lba：扇区开始的lba的值
int ide_pio_read(ide_disk_t *disk, void *buf, u8 count, idx_t lba);
// 写磁盘函数  *buf：从buffer写到磁盘  count：写多少个扇区  lba：扇区开始的lba的值
int ide_pio_write(ide_disk_t *disk, void *buf, u8 count, idx_t lba);
```

## IDE 命令

- #define IDE_CMD_READ 0x20       // 读命令
- #define IDE_CMD_WRITE 0x30      // 写命令
- #define IDE_CMD_IDENTIFY 0xEC   // 识别命令


## PIO 方式读取磁盘

```c
// PIO 方式读取磁盘
int ide_pio_read(ide_disk_t *disk, void *buf, u8 count, idx_t lba)
{
    assert(count > 0);
    assert(!get_interrupt_state()); // 异步方式，调用该函数时不许中断
    ide_ctrl_t *ctrl = disk->ctrl;
    lock_acquire(&ctrl->lock);
    int ret = -EIO;
    ide_select_drive(disk); // 选择磁盘
    if ((ret = ide_busy_wait(ctrl, IDE_SR_DRDY, IDE_TIMEOUT)) < EOK) // 等待就绪
        goto rollback;
    ide_select_sector(disk, lba, count); // 选择扇区
    outb(ctrl->iobase + IDE_COMMAND, IDE_CMD_READ); // 发送读命令
    task_t *task = running_task();
    for (size_t i = 0; i < count; i++)
    {
        // 阻塞自己等待中断的到来，等待磁盘准备数据，数据就绪后读取扇区
        ctrl->waiter = task;
        if ((ret = task_block(task, NULL, TASK_BLOCKED, IDE_TIMEOUT)) < EOK)
            goto rollback;
        if ((ret = ide_busy_wait(ctrl, IDE_SR_DRQ, IDE_TIMEOUT)) < EOK)
            goto rollback;
        u32 offset = ((u32)buf + i * SECTOR_SIZE);
        ide_pio_read_sector(disk, (u16 *)offset); // 读取扇区
    }
    ret = EOK;
rollback:
    lock_release(&ctrl->lock);
    return ret;
}
```


## PIO 方式写磁盘

```c
// PIO 方式写磁盘
int ide_pio_write(ide_disk_t *disk, void *buf, u8 count, idx_t lba)
{
    assert(count > 0);
    assert(!get_interrupt_state()); // 异步方式，调用该函数时不许中断
    ide_ctrl_t *ctrl = disk->ctrl;
    lock_acquire(&ctrl->lock);
    int ret = EOK;
    LOGK("write lba 0x%x\n", lba);
    ide_select_drive(disk); // 选择磁盘
    if ((ret = ide_busy_wait(ctrl, IDE_SR_DRDY, IDE_TIMEOUT)) < EOK) // 等待就绪
        goto rollback;
    ide_select_sector(disk, lba, count); // 选择扇区
    outb(ctrl->iobase + IDE_COMMAND, IDE_CMD_WRITE); // 发送写命令
    task_t *task = running_task();
    for (size_t i = 0; i < count; i++)
    {	
        //直接先写，写完后wait
        u32 offset = ((u32)buf + i * SECTOR_SIZE);
        ide_pio_write_sector(disk, (u16 *)offset);
        // 阻塞自己等待中断的到来，等待磁盘准备数据
        ctrl->waiter = task;
        if ((ret = task_block(task, NULL, TASK_BLOCKED, IDE_TIMEOUT)) < EOK)
            goto rollback;
        if ((ret = ide_busy_wait(ctrl, IDE_SR_NULL, IDE_TIMEOUT)) < EOK)
            goto rollback;
    }
    ret = EOK;
rollback:
    lock_release(&ctrl->lock);
    return ret;
}
```


## 驱动器忙函数

```c
static err_t ide_busy_wait(ide_ctrl_t *ctrl, u8 mask, int timeout_ms)
{
    int expires = timer_expire_jiffies(timeout_ms);
    while (true)
    {
        // 超时
        if (timeout_ms > 0 && timer_is_expires(expires))
        {
            return -ETIME;
        }

        // 从备用状态寄存器中读状态
        u8 state = inb(ctrl->iobase + IDE_ALT_STATUS);
        if (state & IDE_SR_ERR) // 有错误
        {
            ide_error(ctrl);
            ide_reset_controller(ctrl);
            return -EIO;
        }
        if (state & IDE_SR_BSY) // 驱动器忙
        {
            ide_delay();
            continue;
        }
        if ((state & mask) == mask) // 等待的状态完成
            return EOK;
    }
}
```


---


# 5.硬盘异步 PIO

由于同步状态检测，消耗了大量的 CPU 资源，所以可以使用异步的方式来等待硬盘驱动器。给驱动器发送完读写命令后，进程可以进入阻塞态，当驱动器完成一个扇区的操作 (读/写) 时，会发送中断，可以在中断中恢复进程到就绪态，继续执行。


## 中断

当命令以错误结束时，它不会生成 IRQ。每秒检查几次备用状态寄存器以查看是否设置了 ERR 位。否则，直到命令超时您才会知道。


## 处理中断

如果正在使用 IRQ 共享，则需要检查 PCI 总线主状态字节，以验证 IRQ 来自磁盘。如果是这样，就需要读取常规状态寄存器一次，以使磁盘清除其中断标志。如果状态寄存器中的 ERR 位被设置(位 0，值 = 1)，则可能想从错误 IO 端口(主总线上 0x1F1)读取并保存 **错误详细信息** 值。同时还需要向两个 PIC 发送 EOI (0x20)，以清除它们的中断标志。然后需要设置一个标志来“解除”驱动程序，并让它知道发生了另一个 IRQ ——这样驱动程序就可以进行任何必要的数据传输。若仍然处于单请求模式，并且只在 PIO 模式下轮询常规状态寄存器，那么 IRQ 处理器需要做的唯一一件事就是向 PCI 发送 EOI。


## 轮询状态与中断

当驱动发出 PIO 读写命令时，需要等待驱动准备好后才能传输数据。有两种方法可以知道驱动器何时准备好接收数据。当它就绪时，驱动器将发送一个 IRQ。或者，驱动程序可以轮询其中一个状态端口(常规或备用状态)。

轮询的两个优点:

- 轮询的响应速度比 IRQ 快
- 轮询的逻辑比等待 IRQ 简单得多

轮询的一个缺点：

- 在多任务环境中，轮询会耗尽所有CPU时间（单请求模式下该缺点不是问题，CPU 没有更好的事可做）

如何轮询(等待驱动器准备传输数据):

- 读取常规状态端口，直到第 7 位(BSY，值= 0x80)清除，和第 3 位(DRQ，值= 8)设置
- 或直到第 0 位(ERR，值= 1) 或 第 5 位(DF，值= 0x20)设置。
- 如果两个错误位都没有设置，那么设备就已经准备好了


## 抢占/防止中断触发

如果驱动程序在向驱动器发送命令后读取了常规状态端口，则 **响应** IRQ 可能永远不会发生。如果想要接收 IRQs，那么总是读取 **备用状态端口**，而不是常规状态端口。防止 ATA IRQs 发生的更完整的方法是在特定选定驱动器的控制寄存器中设置 nIEN 位。这应该会阻止总线上的驱动器发送任何 IRQs，直到再次清除该位。如果选择了一个驱动器，并且设置了 nIEN，然后选择带有驱动器选择寄存器的另一个驱动器，然后清除 nIEN ——然后第一个驱动器应该永远“记住”它被告知不要发送 irq ——直到再次选择它，并在控制寄存器中写入一个 0 到 nIEN 位。

### 读写多块

在多任务 PIO 模式下，尝试减少 IRQ 数量的一种方法是使用 READ MULTIPLE (0xC4) 和 WRITE MULTIPLE (0xC5) 命令。这些命令使驱动器缓冲区的扇区“块”，并且每个块只发送一个 IRQ，而不是每个扇区发送一个 IRQ。参考 IDENTIFY 命令的 uint16_t 47 和 59 来确定一个块中扇区的数量。您还可以尝试使用 SET MULTIPLE MODE (0xC6) 命令来更改每个块的扇区。

总的来说，PIO 模式是一种慢速传输方式。在实际工作条件下，几乎任何驱动器都应该由 DMA 驱动器控制，而不应该使用 PIO。

## 等待进程的指针

```c
// IDE 控制器
typedef struct ide_ctrl_t
{
    //......
    struct task_t *waiter; // 等待控制器的进程，用于某些位置阻塞
    //......
} ide_ctrl_t;

```

## 初始化（注册硬盘中断，并打开屏蔽字）

```c
set_interrupt_handler(IRQ_HARDDISK, ide_handler); // 注册控制器，中断处理函数
set_interrupt_handler(IRQ_HARDDISK2, ide_handler); // 注册控制器，中断处理函数
set_interrupt_mask(IRQ_HARDDISK, true); // 打开 IRQ_HARDDISK 屏蔽字
set_interrupt_mask(IRQ_HARDDISK2, true); // 打开 IRQ_HARDDISK2 屏蔽字
set_interrupt_mask(IRQ_CASCADE, true); // 打开级联中断屏蔽字
```

## 异步读写

```c
assert(!get_interrupt_state()); // 异步方式，调用该函数时不许中断
```

如果允许中断，有可能在：
```c
outb(ctrl->iobase + IDE_COMMAND, IDE_CMD_READ); // 发送读命令
```
发送读命令后马上产生一个中断。即还没来得及阻塞，中断就已经到来：
```c
ide_handler(int vector)
```
函数中的
```c
if (ctrl->waiter)
{
    // 如果有进程阻塞，则取消阻塞
    task_unblock(ctrl->waiter, EOK);
    ctrl->waiter = NULL;
}
```
的 waiter 是空指针，中断没有起作用，再把自己阻塞之后，就会永远阻塞下去。
写操作同理，需要先写再阻塞再等待。

## 硬盘通道

```c
#define IRQ_HARDDISK 14  // ATA 硬盘第一通道
#define IRQ_HARDDISK2 15 // ATA 硬盘第二通道
```

```asm
INTERRUPT_HANDLER 0x2e, 0; harddisk1 硬盘主通道
INTERRUPT_HANDLER 0x2f, 0; harddisk2 硬盘从通道
```

## 硬盘中断处理函数

```c
// 硬盘中断处理函数
static void ide_handler(int vector)
{
    send_eoi(vector); // 向中断控制器发送中断处理结束信号

    // 得到中断向量对应的控制器
    ide_ctrl_t *ctrl = &controllers[vector - IRQ_HARDDISK - 0x20];

    // 读取常规状态寄存器，表示中断处理结束
    u8 state = inb(ctrl->iobase + IDE_STATUS);
    LOGK("harddisk interrupt vector %d state 0x%x\n", vector, state);
    if (ctrl->waiter)
    {
        // 如果有进程阻塞，则取消阻塞
        task_unblock(ctrl->waiter, EOK);
        ctrl->waiter = NULL;
    }
}
```

## 参考文献

- <https://wiki.osdev.org/PCI_IDE_Controller>
- Information Technology - AT Attachment - 8 ATA/ATAPI Command Set (ATA8-ACS)
- <https://wiki.osdev.org/ATA_PIO_Mode>


---


# 6.识别硬盘

## 标准和非标准检测

目前所有的 BIOS 都标准化了 IDENTIFY 命令的使用，以检测所有类型的 ATA 总线设备的存在 PATA, PATAPI, SATAPI, SATA。


## IDENTIFY 命令

要使用 IDENTIFY 命令：

1. 向 驱动器选择 IO 端口发送命令：
    ① 主驱动器发送 0xA0，端口 0x1F6
    ② 从驱动器发送 0xB0，端口 0x176
2. 将 扇区数量、LBA 等 IO 端口设置为 0 (端口 0x1F2 到 0x1F5) (这步可能不需要)
3. 将 IDENTIFY 命令(0xEC) 发送到命令 IO 端口(0x1F7)
4. 再次读取状态端口(0x1F7)。如果读的值为 0，则表示驱动器不存在
5. 对于任何其他值：轮询状态端口(0x1F7)，直到第7位(BSY, value = 0x80)清除
6. 由于一些 ATAPI 驱动器不符合规范，此时需要检查 LBAmid 和 LBAhi 端口(0x1F4和0x1F5)，以查看它们是否非零。如果是这样，驱动器不是 ATA，您应该停止轮询。否则，继续轮询其中一个状态端口，直到第 3 位(DRQ，值=8)置位，或直到第 0 位(ERR，值=1)置位
7. 如果清除了 ERR，就可以从数据端口(0x1F0)读取数据了。读取 256 个 16 位值，并存储它们


## Bochs 配置文件部分内容

为了识别硬盘，挂了一个光盘
- 从硬盘：类型：磁盘，路径："../build/slave.img"，模式：flat
- ata0-slave: type=disk, path="../build/slave.img", mode=flat


## makefile 文件部分内容

```makefile
$(BuILD)/slave.img:
#创建一个32M的硬盘镜像
yes | bximage -q -hd=32 -func=create -sectsize=512 -imgmode=flat $@

QEMU+=
-drive file=$(BUILD)/slave.img,if=ide,index=1,media=disk,format=raw #从硬盘
```


##  ide 控制器初始化

```c
ide_ctrl_init()
```
ide 控制器初始化函数中
```c
u16 *buf = (u16 *)alloc_kpage(1); //申请一块内存用于读硬盘属性
```
```c
ctrl->waiter = NULL; // waiter 指针设为 NULL
```
```c
ctrl->control = inb(ctrl->iobase + IDE_CONTROL); // 读控制字节
```
```c
free_kpage((u32)buf, 1); // 最后释放内存
```


## 识别硬盘

```c
static err_t ide_identify(ide_disk_t *disk, u16 *buf)
{
    LOGK("identifing disk %s...\n", disk->name);
    lock_acquire(&disk->ctrl->lock); // 加锁
    ide_select_drive(disk); // 选择磁盘

    // ide_select_sector(disk, 0, 0);
    u8 cmd = IDE_CMD_IDENTIFY; // 识别命令 0xEC
    if (disk->interface == IDE_INTERFACE_ATAPI)
    {
        cmd = IDE_CMD_PIDENTIFY;
    }

    outb(disk->ctrl->iobase + IDE_COMMAND, cmd); // 向磁盘发送识别命令

    int ret = EOF;
    if ((ret = ide_busy_wait(disk->ctrl, IDE_SR_NULL, IDE_TIMEOUT)) < EOK)
        goto rollback;

    ide_params_t *params = (ide_params_t *)buf; // ide_params_t 数据结构

    ide_pio_read_sector(disk, buf);

    ide_fixstrings(params->serial, sizeof(params->serial));
    LOGK("disk %s serial number %s\n", disk->name, params->serial);

    ide_fixstrings(params->firmware, sizeof(params->firmware));
    LOGK("disk %s firmware version %s\n", disk->name, params->firmware);

    ide_fixstrings(params->model, sizeof(params->model));
    LOGK("disk %s model number %s\n", disk->name, params->model);

    if (disk->interface == IDE_INTERFACE_ATAPI)
    {
        ret = EOK;
        goto rollback;
    }

    if (params->total_lba == 0) // 等于 0 则磁盘不存在
    {
        ret = -EIO;
        goto rollback;
    }
    LOGK("disk %s total lba %d\n", disk->name, params->total_lba);

    // 赋值
    disk->total_lba = params->total_lba;
    disk->cylinders = params->cylinders;
    disk->heads = params->heads;
    disk->sectors = params->sectors;
    ret = EOK;

rollback:
    lock_release(&disk->ctrl->lock); 释放锁
    return ret;
}
```


## 重置硬盘控制器（一般用不到）

```c
// 重置硬盘控制器
static err_t ide_reset_controller(ide_ctrl_t *ctrl)
{
    // 首先将控制字节设置成字 0x04
    outb(ctrl->iobase + IDE_CONTROL, IDE_CTRL_SRST); 
    ide_delay();
    // 再设置回ctrl->control，ctrl->control 为初始化中的ctrl->control = inb(ctrl->iobase + IDE_CONTROL);
    outb(ctrl->iobase + IDE_CONTROL, ctrl->control); 
    return ide_busy_wait(ctrl, IDE_SR_NULL, IDE_TIMEOUT);
}
```


## 参考文献

- <https://wiki.osdev.org/PCI_IDE_Controller>
- Information Technology - AT Attachment - 8 ATA/ATAPI Command Set (ATA8-ACS)
- <https://wiki.osdev.org/ATA_PIO_Mode>
- <https://gcc.gnu.org/onlinedocs/cpp/Concatenation.html>


---


# 7.硬盘分区

为了实现多个操作系统共享硬盘资源，硬盘可以在逻辑上分为 4 个主分区。每个分区之间的扇区号是邻接的。分区表由 4 个表项组成，每个表项由 16 字节组成，对应一个分区的信息，存放有分区的大小和起止的柱面号、磁道号和扇区号。
分区表存放在硬盘的 0 柱面 0 头第 1 个扇区的 0x1BE ~ 0x1FD 处，即硬盘分区表：64B = 4 * 16B

| 位置 | 大小  | 名称           | 说明                                    |
| ---- | ----- | -------------- | --------------------------------------- |
| 0x00 | 8 位  | bootable       | 引导标志 / 0 - 不可引导 / 0x80 - 可引导 |
| 0x01 | 8 位  | start_head     | 分区起始磁头号                          |
| 0x02 | 6 位  | start_sector   | 分区起始扇区号                          |
| 0x03 | 10 位 | start_cylinder | 分区起始柱面号                          |
| 0x04 | 8 位  | **system**         | 分区类型字节 / 用于表示文件系统         |
| 0x05 | 8 位  | end_head       | 分区的结束磁头号                        |
| 0x06 | 6 位  | end_sector     | 分区结束扇区号                          |
| 0x07 | 10 位 | end_cylinder   | 分区结束柱面号                          |
| 0x08 | 32 位 | **start**          | 分区起始物理扇区号 lba                  |
| 0x0c | 32 位 | **count**          | 分区占用的扇区数                        |


## 扩展分区

扩展分区是一种可以多加 4 个分区的方式。如果分区表中的 SystemID 字段的值位 0x5，表示该分区为扩展分区。

可以将扩展分区的所有扇区组合起来认为是一个新的磁盘，然后再对其进行分区，这种逻辑有点套娃，所以如果磁盘空间足够大，理论上可以分出无数个分区。


## 创建硬盘分区

可以通过 `fdisk` 命令对磁盘进行分区，参考 <https://wiki.archlinux.org/title/Fdisk>

然后可以将分好区的分区信息备份：

- sfdisk -d /dev/... > master.sfdisk

有分区信息可以直接对磁盘进行分区：

- sfdisk /dev/... < master.sfdisk

可以将磁盘挂载到系统：

- sudo losetup /dev/loop0 --partscan master.img

或者取消挂载：

- sudo losetup -d /dev/loop0


## 定义分区数量

- #define IDE_PART_NR 4 // 每个磁盘分区数量，只支持主分区，总共 4 个


## 主引导扇区数据结构

### 主引导扇区
```c
// 主引导扇区 16 字节数据结构
typedef struct part_entry_t
{
    u8 bootable;             // 引导标志
    u8 start_head;           // 分区起始磁头号
    u8 start_sector : 6;     // 分区起始扇区号
    u16 start_cylinder : 10; // 分区起始柱面号
    u8 system;               // 分区类型字节
    u8 end_head;             // 分区的结束磁头号
    u8 end_sector : 6;       // 分区结束扇区号
    u16 end_cylinder : 10;   // 分区结束柱面号
    u32 start;               // 分区起始物理扇区号 LBA
    u32 count;               // 分区占用的扇区数
} _packed part_entry_t;
```

### 主引导扇区内容
```c
// 主引导扇区内容
typedef struct boot_sector_t
{
    u8 code[446]; // 446 字节的代码
    part_entry_t entry[4]; // 64 字节的分区表
    u16 signature; // 2 字节的 0x55aa
} _packed boot_sector_t;
```

### 分区的信息
```c
// 分区的信息，实际上在操作系统里使用的分区的结构
typedef struct ide_part_t
{
    char name[8];            // 分区名称
    struct ide_disk_t *disk; // 磁盘指针
    u32 system;              // 分区类型
    u32 start;               // 分区起始物理扇区号 LBA
    u32 count;               // 分区占用的扇区数
} ide_part_t;
```

### 分区文件系统
```c
// 分区文件系统
// 参考 https://www.win.tue.nl/~aeb/partitions/partition_types-1.html
typedef enum PART_FS
{
    PART_FS_FAT12 = 1,    // FAT12
    PART_FS_EXTENDED = 5, // 扩展分区
    PART_FS_MINIX = 0x80, // minux
    PART_FS_LINUX = 0x83, // linux
} PART_FS;
```


## 读写分区
```c
// 读分区
int ide_pio_part_read(ide_part_t *part, void *buf, u8 count, idx_t lba)
{
    return ide_pio_read(part->disk, buf, count, part->start + lba); // part->start 加上相对地址 lba
}

// 写分区
int ide_pio_part_write(ide_part_t *part, void *buf, u8 count, idx_t lba)
{
    return ide_pio_write(part->disk, buf, count, part->start + lba); // part->start 加上相对地址 lba
}
```


## 分区初始化

```c
ide_ctrl_init()
```
分区初始化函数中的
```c
if (disk->interface == IDE_INTERFACE_ATA)
{
    disk->sector_size = SECTOR_SIZE;
    if (ide_identify(disk, buf) == EOK)
    {
        ide_part_init(disk, buf); // 分区初始化
    }
}
```
其中的 ide_part_init(disk, buf) 分区初始化函数如下：
```c
static void ide_part_init(ide_disk_t *disk, u16 *buf)
{
    // 磁盘不可用
    if (!disk->total_lba)
        return;

    // 读取主引导扇区
    ide_pio_read(disk, buf, 1, 0);

    // 初始化主引导扇区
    boot_sector_t *boot = (boot_sector_t *)buf;

    for (size_t i = 0; i < IDE_PART_NR; i++)
    {   
        // 读entry
        part_entry_t *entry = &boot->entry[i]; 
        ide_part_t *part = &disk->parts[i]; // 初始化 part
        if (!entry->count)
            continue;

        sprintf(part->name, "%s%d", disk->name, i + 1);

        LOGK("part %s \n", part->name);
        LOGK("    bootable %d\n", entry->bootable);
        LOGK("    start %d\n", entry->start);
        LOGK("    count %d\n", entry->count);
        LOGK("    system 0x%x\n", entry->system);

        // 对 part 进行赋值
        part->disk = disk;
        part->count = entry->count;
        part->system = entry->system;
        part->start = entry->start;

        // 扩展分区
        if (entry->system == PART_FS_EXTENDED)
        {
            // 不支持扩展分区
            LOGK("Unsupported extended partition!!!\n"); 

            boot_sector_t *eboot = (boot_sector_t *)(buf + SECTOR_SIZE); // "+ SECTOR_SIZE"：把之前读的扇区覆盖
            ide_pio_read(disk, (void *)eboot, 1, entry->start); // 读扩展分区的主分区，即 entry->start

            for (size_t j = 0; j < IDE_PART_NR; j++)
            {
                part_entry_t *eentry = &eboot->entry[j];
                if (!eentry->count)
                    continue;
                LOGK("part %d extend %d\n", i, j);
                LOGK("    bootable %d\n", eentry->bootable);
                LOGK("    start %d\n", eentry->start);
                LOGK("    count %d\n", eentry->count);
                LOGK("    system 0x%x\n", eentry->system);
            }
        }
    }
}
```


## 参考文献

- <https://wiki.osdev.org/Partition_table>
- <https://wiki.osdev.org/MBR_(x86)>
- [郑刚 / 操作系统真象还原 / 人民邮电出版社 / 2016](https://book.douban.com/subject/26745156/)
- [赵炯 / Linux内核完全注释 / 机械工业出版社 / 2005](https://book.douban.com/subject/1231236/)
- <https://wiki.archlinux.org/title/Fdisk>
- <https://www.win.tue.nl/~aeb/partitions/partition_types-1.html>


---


# 8.虚拟设备

对硬件设备进行一层抽象，使得读写更加的统一，方便以后的操作。


## makefile 添加设备
```makefile
#......
$(BUILD)/kernel/device.o \
#......
```


## 设备相关定义

```c
#define DEVICE_NR 64 // 设备数量
#define NAMELEN 16 // 设备名 16 字节
```


## 设备类型与数据结构

```c
// 设备类型
enum device_type_t
{
    DEV_NULL,  // 空设备
    DEV_CHAR,  // 字符设备 （以 char 为单位）
    DEV_BLOCK, // 块设备 （一个或多个扇区的一块）
    DEV_NET,   // 网络设备
};

// 设备子类型
enum device_subtype_t
{
    DEV_CONSOLE = 1, // 控制台
    DEV_KEYBOARD,    // 键盘
    DEV_SERIAL,      // 串口
    DEV_TTY,         // TTY 设备
    DEV_SB16,        // 声霸卡
    DEV_IDE_DISK,    // IDE 磁盘
    DEV_IDE_PART,    // IDE 磁盘分区
    DEV_IDE_CD,      // IDE 光盘
    DEV_RAMDISK,     // 虚拟磁盘
    DEV_FLOPPY,      // 软盘
    DEV_NETIF,       // 网卡
};

// 设备数据结构
typedef struct device_t
{
    char name[NAMELEN];  // 设备名
    int type;            // 设备类型
    int subtype;         // 设备子类型
    dev_t dev;           // 设备号，"dev_t"："typedef int32 dev_t"
    dev_t parent;        // 父设备号
    void *ptr;           // 设备指针
    list_t request_list; // 块设备请求链表
    bool direct;         // 磁盘寻道方向
    // 设备控制 
    int (*ioctl)(void *dev, int cmd, void *args, int flags);
    // 读设备
    // "*dev"： *ptr设备指针
    // "*buf"： 读写缓冲区
    // "count"：读写数量
    // "idx"：  扇区号
    int (*read)(void *dev, void *buf, size_t count, idx_t idx, int flags);
    // 写设备
    int (*write)(void *dev, void *buf, size_t count, idx_t idx, int flags);
} device_t;
```


## 设备初始化

```c
void device_init()
{
    for (size_t i = 0; i < DEVICE_NR; i++)
    {
        device_t *device = &devices[i];
        strcpy((char *)device->name, "null"); // 设备置为 null
        device->type = DEV_NULL; // 空指针
        device->subtype = DEV_NULL; // 空指针
        device->dev = i;
        device->parent = 0; // 父设备为 0
        device->ioctl = NULL; // 空指针
        device->read = NULL; // 空指针
        device->write = NULL; // 空指针

        list_init(&device->request_list);
        device->direct = DIRECT_UP;
    }
}
```
```asm
_start:
    push ebx; ards_count
    push eax; magic
    call onix_init      ; 检测内核完整性
    call device_init    ; 虚拟设备初始化
    call console_init   ; 控制台初始化

    ; xchg bx, bx
    call gdt_init       ; 全局描述符初始化
    ; xchg bx, bx

    lgdt [gdt_ptr]

    jmp dword code_selector:_next
```


## 安装设备

```c
// 获取空设备
static device_t *get_null_device()
{
    for (size_t i = 1; i < DEVICE_NR; i++)
    {
        device_t *device = &devices[i];
        if (device->type == DEV_NULL)
            return device;
    }
    panic("no more devices!!!");
}

// 安装设备
dev_t device_install(
    int type, int subtype,
    void *ptr, char *name, dev_t parent,
    void *ioctl, void *read, void *write)
{
    // 获取一个空的设备
    device_t *device = get_null_device(); 
    // 参数赋值
    device->ptr = ptr;
    device->parent = parent;
    device->type = type;
    device->subtype = subtype;
    strncpy(device->name, name, NAMELEN);
    device->ioctl = ioctl;
    device->read = read;
    device->write = write;
    // 返回设备的设备号
    return device->dev; 
}

// 根据子类型查找设备
device_t *device_find(int subtype, idx_t idx)
{
    idx_t nr = 0;
    for (size_t i = 0; i < DEVICE_NR; i++)
    {
        device_t *device = &devices[i];
        if (device->subtype != subtype) // 从设备表表里查出子类型是子类型中的第几个的设备
            continue;
        if (nr == idx)
            return device;
        nr++;
    }
    return NULL;
}

// 根据设备号查找设备
device_t *device_get(dev_t dev) // 设备号
{
    assert(dev < DEVICE_NR);
    device_t *device = &devices[dev]; // 得到设备号对应的设备
    assert(device->type != DEV_NULL); // 不为空指针
    return device; // 返回设备
}

// 控制设备
int device_ioctl(dev_t dev, int cmd, void *args, int flags)
{
    device_t *device = device_get(dev);
    if (device->ioctl)
    {
        return device->ioctl(device->ptr, cmd, args, flags);
    }
    LOGK("ioctl of device %d not implemented!!!\n", dev);
    return -ENOSYS;
}

// 读设备
int device_read(dev_t dev, void *buf, size_t count, idx_t idx, int flags)
{
    device_t *device = device_get(dev); // 获取设备
    if (device->read) // 不为空指针，则调用读函数
    {
        return device->read(device->ptr, buf, count, idx, flags);
    }
    LOGK("read of device %d not implemented!!!\n", dev);
    return -ENOSYS; // 否则报错
}

// 写设备
int device_write(dev_t dev, void *buf, size_t count, idx_t idx, int flags)
{
    device_t *device = device_get(dev); // 获取设备
    if (device->write) // 不为空指针，则调用写函数
    {
        return device->write(device->ptr, buf, count, idx, flags); 
    }
    LOGK("write of device %d not implemented!!!\n", dev);
    return -ENOSYS; // 否则报错
}
```


## 适配设备
```c
console_init()
```
函数中：
```c
device_install(
    DEV_CHAR, DEV_CONSOLE, // 字符设备 控制台
    con, "console", 0, // 指针 设别名”console“ 设备0
    NULL, NULL, console_write); // 控制函数空 读函数空 写函数非空（即控制台值可以写）
}
```


---


# 9.块设备请求

块设备 (如硬盘，软盘) 的读写以扇区(512B) 为单位，操作比较耗时，需要寻道，寻道时需要旋转磁头臂。所以需要一种策略来完成磁盘的访问。


## 数据类型

```c
// 设备子类型
enum device_subtype_t
{
    //......
    DEV_IDE_DISK,    // IDE 磁盘
    DEV_IDE_PART,    // IDE 磁盘分区
    //......
};

// 设备控制命令
enum device_cmd_t
{
    DEV_CMD_SECTOR_START = 1, // 获得设备扇区开始位置 lba
    DEV_CMD_SECTOR_COUNT,     // 获得设备扇区数量
    DEV_CMD_SECTOR_SIZE,      // 获得设备扇区大小
};

// 块设备请求
typedef struct request_t
{
    dev_t dev;           // 设备号
    u32 type;            // 请求类型
    u32 idx;             // 扇区位置
    u32 count;           // 扇区数量
    int flags;           // 特殊标志
    u8 *buf;             // 缓冲区
    struct task_t *task; // 请求进程
    list_node_t node;    // 列表节点
} request_t;

typedef struct device_t
{
    //......
    list_t request_list; // 块设备请求链表
    //......
} device_t;
```


## 设备请求的类型定义
- 块设备读：#define REQ_READ 0
- 块设备写：#define REQ_WRITE 1


## 设备请求函数

```c++
// 块设备请求
// "dev"：访问的设备 
// "*buf"：缓冲区
// "count"：扇区数量
// "idx"：扇区开始的位置
// "type"：访问的类型
err_t device_request(dev_t dev, void *buf, u8 count, idx_t idx, int flags, u32 type)
{
    device_t *device = device_get(dev);
    assert(device->type = DEV_BLOCK); // 是块设备
    idx_t offset = idx + device_ioctl(device->dev, DEV_CMD_SECTOR_START, 0, 0); // "offset"：磁盘扇区的位置

    if (device->parent) // 如果有父设备则找到其磁盘，对磁盘进行操作
    {
        device = device_get(device->parent);
    }

    // 申请一块内存用来存放请求的参数
    request_t *req = kmalloc(sizeof(request_t)); 
    memset(req, 0, sizeof(request_t));

    // 给参数赋值
    req->dev = device->dev;
    req->buf = buf;
    req->count = count;
    req->idx = offset;
    req->flags = flags;
    req->type = type;
    req->task = NULL;

    LOGK("dev %d request idx %d\n", req->dev, req->idx);

    // 判断列表是否为空
    bool empty = list_empty(&device->request_list);

    // 将请求压入链表
    // list_push(&device->request_list, &req->node);

    // 将请求插入链表
    list_insert_sort(&device->request_list, &req->node, element_node_offset(request_t, node, idx));

    // 如果列表不为空，则阻塞，因为已经有请求在处理了，等待处理完成唤醒
    if (!empty)
    {
        req->task = running_task();
        assert(task_block(req->task, NULL, TASK_BLOCKED, TIMELESS) == EOK);
    }

    // 执行请求
    err_t ret = do_request(req);

    request_t *nextreq = request_nextreq(device, req);

    // 将 node 从链表中移除
    list_remove(&req->node); 
    kfree(req);

    if (nextreq)
    {
        assert(nextreq->task->magic == ONIX_MAGIC);
        task_unblock(nextreq->task, EOK); // 唤醒进程
    }

    return ret;
}

// 设备初始化
void device_init()
{
    for (size_t i = 0; i < DEVICE_NR; i++)
    {
        // ......
        list_init(&device->request_list); // 将链表初始化
        // ......
    }
}
```


## 任务初始化

```c
void task_init()
{
    list_init(&block_list);
    list_init(&sleep_list);

    task_setup();

    idle_task = task_create(idle_thread, "idle", 1, KERNEL_USER);
    task_create(init_thread, "init", 5, NORMAL_USER); // 创建
}
```


## ide 硬盘初始化

```c
// ide 硬盘初始化
void ide_init()
{
    LOGK("ide init...\n");

    // 注册硬盘中断，并打开屏蔽字
    set_interrupt_handler(IRQ_HARDDISK, ide_handler);
    set_interrupt_handler(IRQ_HARDDISK2, ide_handler);
    set_interrupt_mask(IRQ_HARDDISK, true);
    set_interrupt_mask(IRQ_HARDDISK2, true);
    set_interrupt_mask(IRQ_CASCADE, true);

    ide_ctrl_init();

    ide_install(); // 安装设备
}

// 安装设备，遍历所有扇区和磁盘，将磁盘安装
static void ide_install()
{
    void *read = ide_pio_read;
    void *write = ide_pio_write;

    for (size_t cidx = 0; cidx < IDE_CTRL_NR; cidx++)
    {
        ide_ctrl_t *ctrl = &controllers[cidx];
        if (ctrl->iotype == IDE_TYPE_UDMA)
        {
            read = ide_udma_read;
            write = ide_udma_write;
        }

        for (size_t didx = 0; didx < IDE_DISK_NR; didx++)
        {
            ide_disk_t *disk = &ctrl->disks[didx];
            if (!disk->total_lba)
                continue;

            if (disk->interface == IDE_INTERFACE_ATA)
            {
                dev_t dev = device_install(
                    DEV_BLOCK, DEV_IDE_DISK, disk, disk->name, 0, // 磁盘为块设备，子类型为磁盘，指针为磁盘指针，父设备为 0 
                    ide_pio_ioctl, read, write); // 父设备为磁盘
                for (size_t i = 0; i < IDE_PART_NR; i++)
                {
                    ide_part_t *part = &disk->parts[i];
                    if (!part->count)  
                        continue;
                    device_install( // 扇区的 count 不为 0 则注册
                        DEV_BLOCK, DEV_IDE_PART, part, part->name, dev,
                        ide_pio_part_ioctl, ide_pio_part_read, ide_pio_part_write); //块设备是分区
                }
            }
            else if (disk->interface == IDE_INTERFACE_ATAPI)
            {
                device_install(
                    DEV_BLOCK, DEV_IDE_CD, disk, disk->name, 0,
                    ide_pio_ioctl, ide_atapi_read, NULL); 
            }
        }
    }
}
```


## 相关控制函数

```c
// 磁盘控制
int ide_pio_ioctl(ide_disk_t *disk, int cmd, void *args, int flags)
{
    switch (cmd)
    {
    case DEV_CMD_SECTOR_START: // 扇区开始位置：0
        return 0;
    case DEV_CMD_SECTOR_COUNT: // 扇区数量：disk->total_lba
        return disk->total_lba;
    case DEV_CMD_SECTOR_SIZE:
        return disk->sector_size;
    default:
        panic("device command %d can't recognize!!!", cmd);
        break;
    }
}

// 分区控制
int ide_pio_part_ioctl(ide_part_t *part, int cmd, void *args, int flags)
{
    switch (cmd)
    {
    case DEV_CMD_SECTOR_START: // 分区的开始位置
        return part->start;
    case DEV_CMD_SECTOR_COUNT: // 分区的扇区数量
        return part->count;
    case DEV_CMD_SECTOR_SIZE:
        return part->disk->sector_size;
    default:
        panic("device command %d can't recognize!!!", cmd);
        break;
    }
}
```


## 执行块设备请求

```c
// 执行块设备请求
static int do_request(request_t *req)
{
    LOGK("dev %d do request idx %d\n", req->dev, req->idx);

    switch (req->type)
    {
    case REQ_READ: // 执行设备读
        return device_read(req->dev, req->buf, req->count, req->idx, req->flags);
        break;
    case REQ_WRITE: // 执行设备写
        return device_write(req->dev, req->buf, req->count, req->idx, req->flags);
        break;
    default:
        panic("req type %d unknown!!!");
        break;
    }
}
```


## 参考文献

- [赵炯 / Linux内核完全注释 / 机械工业出版社 / 2005](https://book.douban.com/subject/1231236/)


---


# 10.磁盘调度电梯算法

由于磁盘性能的主要瓶颈在磁盘的寻道时间，即磁头臂的移动时间，所以要尽可能避免磁头臂的移动。电梯算法的作用是让磁头的综合移动距离最小，从而改善磁盘访问时间。


## LBA 和 CHS

- LBA (Logical Block Addressing)：逻辑块寻址，逻辑上认为磁盘的扇区编号从 0 开始依次递增，处理起来更方便；
- Sector: 扇区，磁盘最小的单位，多个扇区够称一个磁道
- Head: 磁头，用于读写盘面，一个磁盘可能有多个磁头，一个磁道读写完成，就换另一个磁头；
- Cylinder：柱面，或者也可以认为是磁道 (Track)，同一个位置的所有磁道共同构成了柱面；当所有磁道都读写完时，就需要切换磁道，也就产生了寻道的问题。因此柱面是磁盘读写最大的单位。

LBA 和 CHS 的转换公式：
- CYL = LBA / (HPC * SPT)
- HEAD = (LBA % (HPC * SPT)) / SPT
- SECT = (LBA % (HPC * SPT)) % SPT + 1
- LBA = ( ( CYL * HPC + HEAD ) * SPT ) + SECT - 1

其中：
- CYL 表示柱面 (Cylinder)
- HEAD 表示磁头 (Head)
- SECT 表示扇区 (Sector)
- LBA 表示逻辑块地址 (Logical Block Addressing)
- HPC 表示柱面磁头数 (Head Per Cylinder)
- SPT 表示磁道扇区数 (Sector Per Track)


## 电梯算法相关定义

- “向上”：#define DIRECT_UP 0    
- “向下”：#define DIRECT_DOWN 1  


## 电梯算法相关数据类型

```c
typedef struct device_t
{
    //......
    bool direct; // 磁盘寻道方向   
    //......
} device_t;
```


## 初始化

```c
void device_init()
{
    for (size_t i = 0; i < DEVICE_NR; i++)
    {
        device_t *device = &devices[i];
        strcpy((char *)device->name, "null");
        device->type = DEV_NULL;
        device->subtype = DEV_NULL;
        device->dev = i;
        device->parent = 0;
        device->ioctl = NULL;
        device->read = NULL;
        device->write = NULL;

        list_init(&device->request_list);
        device->direct = DIRECT_UP; // 初始化磁盘寻道方向为"向上" 
    }
}
```


## 插入排序

```c
// 块设备请求
err_t device_request(dev_t dev, void *buf, u8 count, idx_t idx, int flags, u32 type)
{
    device_t *device = device_get(dev);
    assert(device->type = DEV_BLOCK); // 是块设备
    idx_t offset = idx + device_ioctl(device->dev, DEV_CMD_SECTOR_START, 0, 0);

    if (device->parent)
    {
        device = device_get(device->parent);
    }

    request_t *req = kmalloc(sizeof(request_t));
    memset(req, 0, sizeof(request_t));

    req->dev = device->dev;
    req->buf = buf;
    req->count = count;
    req->idx = offset;
    req->flags = flags;
    req->type = type;
    req->task = NULL;

    LOGK("dev %d request idx %d\n", req->dev, req->idx);

    // 判断列表是否为空
    bool empty = list_empty(&device->request_list);

    // 将请求压入链表
    // list_push(&device->request_list, &req->node);

    // 将请求插入链表：插入排序
    list_insert_sort(&device->request_list, &req->node, element_node_offset(request_t, node, idx));

    // 如果列表不为空，则阻塞，因为已经有请求在处理了，等待处理完成；
    if (!empty)
    {
        req->task = running_task();
        assert(task_block(req->task, NULL, TASK_BLOCKED, TIMELESS) == EOK);
    }

    err_t ret = do_request(req);

    // 获得下一个请求
    request_t *nextreq = request_nextreq(device, req);

    // 从链表中移除
    list_remove(&req->node);
    kfree(req);

    if (nextreq) // 请求不为空，即还有请求
    {
        assert(nextreq->task->magic == ONIX_MAGIC);
        task_unblock(nextreq->task, EOK); // 接触阻塞
    }

    return ret;
}

// 链表插入排序  递增排序
// "*list"：列表  "*node"：要插入的列表  "offset"
void list_insert_sort(list_t *list, list_node_t *node, int offset)
{
    // 从链表找到第一个比当前节点 key 点更大的节点，进行插入到前面
    list_node_t *anchor = &list->tail;
    int key = element_node_key(node, offset);
    for (list_node_t *ptr = list->head.next; ptr != &list->tail; ptr = ptr->next)
    {
        int compare = element_node_key(ptr, offset);
        if (compare > key)
        {
            anchor = ptr;
            break;
        }
    }

    assert(node->next == NULL);
    assert(node->prev == NULL);

    // 插入链表
    list_insert_before(anchor, node);
}
```

- 求 node 和 ticks 的 offset： #define element_node_offset(type, node, key) ((int)(&((type *)0)->key) - (int)(&((type *)0)->node))
- 通过 node 得到 ticks 的值：#define element_node_key(node, offset) *(int *)((int)node + offset)

```c
// 获得下一个请求
static request_t *request_nextreq(device_t *device, request_t *req)
{
    list_t *list = &device->request_list;

    if (device->direct == DIRECT_UP && req->node.next == &list->tail) // 如果“向上”且下一个请求到结尾
    {
        device->direct = DIRECT_DOWN; // 改成“向下”
    }
    else if (device->direct == DIRECT_DOWN && req->node.prev == &list->head) // 如果“向下”且下一个请求到开头
    {
        device->direct = DIRECT_UP; // 改成“向上”
    }

    void *next = NULL;
    if (device->direct == DIRECT_UP) // “向上”
    {
        next = req->node.next; // 得到 next
    }
    else
    {
        next = req->node.prev; // 得到 next
    }

    if (next == &list->head || next == &list->tail)
    {
        return NULL; // 结束
    }

    return element_entry(request_t, node, next); // 得到请求，返回指针
}
```


## 参考文献

- [赵炯 / Linux内核完全注释 / 机械工业出版社 / 2005](https://book.douban.com/subject/1231236/)
- <https://en.wikipedia.org/wiki/Elevator_algorithm>


---


# 11.串口设备驱动

**串口驱动**对系统开发者来说实现起来简单，通常用于调试的目的。本次项目使用串口代替 USB 进行调试。


## 串口编程

对 UART 的编程实际上是对其内部寄存器执行读写操作。因此可将 UART 看作是一组寄存器集合，包含发送、接收和控制三部分。UART 内部有 10 个寄存器，供 CPU 通过 `in/out` 指令对其进行访问。


## 端口

- 0x3F8 ~ 0x3fE 对应 COM1 串口
- 0x2F8 ~ 0x2FE 对应 COM2 串口

有了 COM 端口的基址，就可以加一个偏移值来访问其中的一个数据寄存器，其中一个寄存器保存着条件 DLAB(Divisor Latch Access Bit) 是除数锁存访问位，是线控制寄存器的位 7，当该位置位时，偏移量 0 和 1 被映射到设置端口波特率的除数寄存器的低字节和高字节。当该位清除时，偏移量 0 和 1 被映射到其正常的寄存器，DLAB 位只影响前两个寄存器，其他寄存器会忽略此设置。

| 偏移 | DLAB | 描述                             |
| ---- | ---- | -------------------------------- |
| 0    | 0    | **读写数据**                     |
| 0    | 1    | 读/写 波特率因子低字节 (LSB)     |
| 1    | 0    | **读写中断允许寄存器**           |
| 1    | 1    | 读/写 波特率因子高字节 (MSB)     |
| 2    | -    | 中断识别和 IO 控制寄存器         |
| 3    | -    | 线控制寄存器，最重要的是 DLAB 位 |
| 4    | -    | 调制解调器控制寄存器             |
| 5    | -    | **线状态寄存器**                     |
| 6    | -    | 调制解调器状态寄存器             |
| 7    | -    | 暂存寄存器                       |

### 寄存器 1 DLAB = 0 中断允许寄存器

要在中断模式下与串口通信，必须正确设置中断允许寄存器(见上表)。为了确定应该启用哪些中断，必须将具有以下位的值 (0 = disabled, 1 = enabled) 写入中断允许寄存器:

| 位   | 描述      |
| ---- | --------- |
| 0    | 数据可用  |
| 1    | 传输器空  |
| 2    | 中断/错误 |
| 3    | 状态变化  |
| 其他 | 保留      |

### 寄存器 2 中断识别寄存器（读） [^serport]

- 位 0：
    - 0：有待处理中断
    - 1：无中断
- 位 2 ~ 1：
    - 11 接收状态有错中断，优先级最高
    - 10 已接收到数据中断，优先级第 2
    - 01 发送保持寄存器空中断，优先级第 3
    - 00 调制解调器状态改变中断，优先级第 4
- 其他：保留

### 寄存器 2 FIFO 控制寄存器（写）

- 位 0：FIFO 有效
- 位 1：清空接收 FIFO
- 位 2：清空发送 FIFO
- 位 3：DMA 模式
- 位 6 ~ 7：中断触发电平

### 寄存器 3 线控制寄存器

通过线路传输的串行数据可以设置许多不同的参数。通常发送设备和接收设备要求向每个串行控制器写入相同的协议参数值以成功通信。

### 寄存器 4 调制解调器控制寄存器

调制解调器控制寄存器是硬件握手寄存器的一部分。虽然大多数串行设备不再使用硬件握手，但仍然包括在所有 16550 兼容 UART 设备。这些可以用作通用输出端口，或用于执行握手。通过写入调制解调器控制寄存器，它将使这些线处于活动状态。

| 位    | 名称         | 英文                      | 含义                                   |
| ----- | ------------ | ------------------------- | -------------------------------------- |
| 0     | 数据终端就绪 | Data Terminal Ready (DTR) | 控制数据终端准备引脚                   |
| 1     | 发送请求     | Request to Send (RTS)     | 控制发送请求引脚                       |
| 2     | 引脚 1       | Out 1                     | 控制硬件引脚 1, PC 中未实现            |
| 3     | 引脚 2       | Out 2                     | 控制硬件引脚 2, PC 中启用中断          |
| 4     | 本地回环     | Loop                      | 提供本地环回特性，用于 UART 的诊断测试 |
| 5 ~ 7 | 0            | 0                         | 未使用                                 |

### 寄存器 5 线状态寄存器

线状态寄存器用于检查错误和启用轮询。

| 位  | 名称                                      | 含义                               |
| --- | ----------------------------------------- | ---------------------------------- |
| 0   | Data ready (DR)                           | 数据就绪可读                       |
| 1   | Overrun error (OE)                        | 数据溢出丢失                       |
| 2   | Parity error (PE)                         | 奇偶校验错误                       |
| 3   | Framing error (FE)                        | 停止位丢失                         |
| 4   | Break indicator (BI)                      | 数据输入中有中断                   |
| 5   | Transmitter holding register empty (THRE) | 设置传输缓冲区为空(即数据可以发送) |
| 6   | Transmitter empty (TEMT)                  | 如果发送端空                       |
| 7   | Impending Error                           | 输入缓冲区中的单词出现错误         |

### 寄存器 6 调制解调器状态寄存器

### 寄存器 7 暂存寄存器


## qemu

### qemu 虚拟机配置串口方式
```
QEMU+= -chardev stdio,mux=on,id=com1 # 字符设备 1
# QEMU+= -chardev vc,mux=on,id=com1 # 字符设备 1
QEMU+= -chardev udp,id=com2,port=6666,ipv4=on # 字符设备 2
QEMU+= -serial chardev:com1 # 串口 1
QEMU+= -serial chardev:com2 # 串口 2
```
其中：
- `stdio` 表示将字符输出到终端
- `vc` 是 qemu 默认的虚拟终端，可以在 TAB (View -> Show Tabs)中打开
- `udp` 用 udp 协议传输字符数据，主要可以用 netcat 来调试

### netcat

可以用 nc 建立服务器端，监听端口号 6666：
- nc -ulp 6666

用 nc 建立客户端，连接刚建好的服务器：
- nc -u localhost 6666

即可互相通信。同时 nc 可以监听 6666 端口以调试 qemu 的串口。


## 数据结构

```c
// 设备子类型
enum device_subtype_t
{
    //......
    DEV_SERIAL,      // 串口
    //......
};
```
```c
// 串口结构体
typedef struct serial_t
{
    u16 iobase;           // 端口号基地址
    fifo_t rx_fifo;       // 读 fifo
    char rx_buf[BUF_LEN]; // 读 缓冲
    lock_t rlock;         // 读锁
    task_t *rx_waiter;    // 读等待任务
    lock_t wlock;         // 写锁
    task_t *tx_waiter;    // 写等待任务
} serial_t;
```


## 串口相关定义

### 串口的中断
```assembly
INTERRUPT_HANDLER 0x23, 0; com2 串口2
INTERRUPT_HANDLER 0x24, 0; com1 串口1
```

### QEMU串口设备的参数
```Makefile
QEMU+= -chardev stdio,mux=on,id=com1 # 字符设备 1
# QEMU+= -chardev vc,mux=on,id=com1 # 字符设备 1
QEMU+= -chardev vc,mux=on,id=com2 # 字符设备 2
# QEMU+= -chardev udp,mux=on,id=com2,port=6666,ipv4=on # 字符设备 2
QEMU+= -serial chardev:com1 # 串口 1
QEMU+= -serial chardev:com2 # 串口 2
```

### 串口的基地址
- 串口 1 基地址：#define COM1_IOBASE 0x3F8
- 串口 2 基地址：#define COM2_IOBASE 0x2F8 

## 寄存器的偏移
#define COM_DATA 0          // 数据寄存器
#define COM_INTR_ENABLE 1   // 中断允许
#define COM_BAUD_LSB 0      // 波特率低字节
#define COM_BAUD_MSB 1      // 波特率高字节
#define COM_INTR_IDENTIFY 2 // 中断识别
#define COM_LINE_CONTROL 3  // 线控制
#define COM_MODEM_CONTROL 4 // 调制解调器控制
#define COM_LINE_STATUS 5   // 线状态
#define COM_MODEM_STATUS 6  // 调制解调器状态

### 线状态
- #define LSR_DR 0x1
- #define LSR_OE 0x2
- #define LSR_PE 0x4
- #define LSR_FE 0x8
- #define LSR_BI 0x10
- #define LSR_THRE 0x20
- #define LSR_TEMT 0x40
- #define LSR_IE 0x80


## 初始化

```c
// 初始化串口
void serial_init()
{
    for (size_t i = 0; i < 2; i++)
    {
        serial_t *serial = &serials[i]; // 得到串口的结构
        fifo_init(&serial->rx_fifo, serial->rx_buf, BUF_LEN); // 初始化队列
        serial->rx_waiter = NULL; // 进程置为空
        lock_init(&serial->rlock); // 读锁
        serial->tx_waiter = NULL; // 进程置为空
        lock_init(&serial->wlock); // 写锁

        u16 irq;
        if (!i)
        {
            irq = IRQ_SERIAL_1; // 中断号：4
            serial->iobase = COM1_IOBASE; // 串口 1 的基地址
        }
        else
        {
            irq = IRQ_SERIAL_2; // 中断号：3
            serial->iobase = COM2_IOBASE; // 串口 2 的基地址
        }

        // 禁用中断
        outb(serial->iobase + COM_INTR_ENABLE, 0);

        // 激活 DLAB
        outb(serial->iobase + COM_LINE_CONTROL, 0x80);

        // 设置波特率因子 0x0030
        // 波特率为 115200 / 0x30 = 115200 / 48 = 2400
        outb(serial->iobase + COM_BAUD_LSB, 0x30);
        outb(serial->iobase + COM_BAUD_MSB, 0x00);

        // 复位 DLAB 位，数据位为 8 位
        outb(serial->iobase + COM_LINE_CONTROL, 0x03);

        // 启用 FIFO, 清空 FIFO, 14 字节触发电平
        outb(serial->iobase + COM_INTR_IDENTIFY, 0xC7);

        // 设置回环模式，测试串口芯片
        outb(serial->iobase + COM_MODEM_CONTROL, 0b11011);

        // 发送字节
        outb(serial->iobase, 0xAE);

        // 收到的内容与发送的不一致，则串口不可用
        if (inb(serial->iobase) != 0xAE)
        {
            continue;
        }

        // 设置回原来的模式
        outb(serial->iobase + COM_MODEM_CONTROL, 0b1011);

        // 注册中断函数
        set_interrupt_handler(irq, serial_handler);

        // 打开中断屏蔽
        set_interrupt_mask(irq, true);

        // 0x0d = 0b1101
        // 数据可用 + 中断/错误 + 状态变化 都发送中断
        outb(serial->iobase + COM_INTR_ENABLE, 0x0F);

        char name[16];

        sprintf(name, "com%d", i + 1);

        device_install(
            DEV_CHAR, DEV_SERIAL, serial, name, 0,
            NULL, serial_read, serial_write);

        LOGK("Serial 0x%x init...\n", serial->iobase);
    }
}
```


## 中断处理、读写函数

```c
void recv_data(serial_t *serial)
{
    char ch = inb(serial->iobase);
    if (ch == '\r') // 特殊处理，回车键直接换行
    {
        ch = '\n';
    }
    fifo_put(&serial->rx_fifo, ch);
    if (serial->rx_waiter != NULL) // 读进程不为空
    {
        task_unblock(serial->rx_waiter, EOK); // 解除阻塞
        serial->rx_waiter = NULL;
    }
}

// 中断处理函数
void serial_handler(int vector)
{
    u32 irq = vector - 0x20;
    assert(irq == IRQ_SERIAL_1 || irq == IRQ_SERIAL_2);
    send_eoi(vector); // 通知中断控制器，中断处理结束

    serial_t *serial = &serials[irq - IRQ_SERIAL_1];
    u8 state = inb(serial->iobase + COM_LINE_STATUS); // 读取状态

    if (state & LSR_DR) // 数据可读
    {
        recv_data(serial);
    }

    // 如果可以发送数据，并且写进程阻塞
    if ((state & LSR_THRE) && serial->tx_waiter)
    {
        task_unblock(serial->tx_waiter, EOK);
        serial->tx_waiter = NULL;
    }
}

// 读
int serial_read(serial_t *serial, char *buf, u32 count)
{
    lock_acquire(&serial->rlock); // 读锁加锁
    int nr = 0;
    while (nr < count)
    {
        while (fifo_empty(&serial->rx_fifo)) // 为空则阻塞
        {
            assert(serial->rx_waiter == NULL);
            serial->rx_waiter = running_task();
            task_block(serial->rx_waiter, NULL, TASK_BLOCKED, TIMELESS);
        }
        buf[nr++] = fifo_get(&serial->rx_fifo); // 不为空则读
    }
    lock_release(&serial->rlock); // 读锁释放
    return nr;
}

// 写
int serial_write(serial_t *serial, char *buf, u32 count)
{
    lock_acquire(&serial->wlock); // 写锁加锁
    int nr = 0;
    while (nr < count)
    {
        u8 state = inb(serial->iobase + COM_LINE_STATUS);
        if (state & LSR_THRE) // 如果串口可写
        {
            outb(serial->iobase, buf[nr++]);
            continue;
        }
        // task_t *task = running_task();
        // serial->tx_waiter = task;
        // task_block(task, NULL, TASK_BLOCKED, TIMELESS);
    }
    lock_release(&serial->wlock); // 写锁释放
    return nr;
}
```


## 参考文献

- <https://wiki.osdev.org/Serial_Ports>
- <https://en.wikipedia.org/wiki/RS-232>
- <https://en.wikipedia.org/wiki/D-subminiature>
- 赵炯 - 《Linux内核完全注释》
- <https://www.sci.muni.cz/docs/pc/serport.txt> 
- <https://stackoverflow.com/questions/27937916/whats-the-difference-between-com-usb-serial-port>
- <https://www.qemu.org/docs/master/system/qemu-manpage.html> 关于 qemu 的配置
- <https://netcat.sourceforge.net/>


---


# 12.CSI 控制序列

## 控制字符

控制字符是指 ASCII 码表开头的 32 个字符 (0x00 ~ 0x1F) 以及 DEL(0x7F)；通常一个指定类型的终端都会采用其中的一个子集作为控制字符，而其它的控制字符将不起作用。例如，对于 VT100 终端所采用的控制字符如下表所示：
| 控制字符 | 八进制 | 十六进制 | 描述                                                                 |
| -------- | ------ | -------- | -------------------------------------------------------------------- |
| NUL      | 0      | 0x00     | 在输入时忽略，不保存在输入缓冲中                                     |
| ENQ      | 5      | 0x05     | 传送应答消息                                                         |
| BEL      | 7      | 0x07     | 从键盘发声响                                                         |
| BS       | 10     | 0x08     | 将光标移向左边一个字符位置处；若光标已经处在左边沿，则无动作         |
| HT       | 11     | 0x09     | 将光标移到下一个制表位；若右侧已经没有制表位，则移到右边缘处         |
| LF       | 12     | 0x0A     | 此代码导致一个回车或换行操作                                         |
| VT       | 13     | 0x0B     | 作用如LF                                                             |
| FF       | 14     | 0x0C     | 作用如LF                                                             |
| CR       | 15     | 0x0D     | 将光标移到当前行的左边缘处                                           |
| SO       | 16     | 0x0E     | 使用由 SCS 控制序列设计的 G1 字符集                                  |
| SI       | 17     | 0x0F     | 选择 G0 字符集，由 ESC 序列选择                                      |
| XON      | 21     | 0x11     | 使终端重新进行传输                                                   |  |
| XOFF     | 23     | 0x13     | 使中断除发送 XOFF  和 XON 以外，停止发送其它所有代码                 |
| CAN      | 30     | 0x18     | 如果在控制序列期间发送，则序列不会执行而立刻终止，同时会显示出错字符 |
| SUB      | 32     | 0x1A     | 作用同 CAN                                                           |  |
| ESC      | 33     | 0x1B     | 产生一个控制序列                                                     |  |
| DEL      | 177    | 0x7F     | 在输入时忽略 不保存在输入缓冲中                                      |

## 控制序列

控制序列是指由一些非控制字符构成的一个特殊字符序列，终端在收到这个序列时并不是将它们直接显示在屏幕上，而是采取一定的控制操作，例如：
- 移动光标
- 删除字符
- 删除行
- 插入字符
- 插入行

ANSI 控制序列由以下一些基本元素组成：
- 控制序列引入码(Control Sequence Introducer - CSI)：表示一个转移序列，提供辅助的控制并且本身是影响随后一系列连续字符含义解释的前缀。通常，一般 CSI 都使用 `ESC[`
- 参数(Parameter)：零个或多个数字字符组成的一个数值
- 数值参数(Numeric Parameter)：表示一个数的参数，使用 `n` 表示
- 选择参数(Selective Parameter)：用于从一功能子集中选择一个子功能，一般用 `s` 表示；通常，具有多个选择参数的一个控制序列所产生的作用，如同分立的几个控制序列；例如：`CSI sa;sb;sc F` 的作用是与 `CSI sa F CSI sb F CSI sc F` 完全一样的
- 参数字符串(Parameter String)：用分号 `;` 隔开的参数字符串
- 默认值(Default)：当没有明确指定一个值或者值是 0 的话，就会指定一个与功能相关的值
- 最后字符(Final character)：用于结束一个转义或控制序列

下表是一些常用的控制序列列表，其中 E 表示 0x1B，如果 n 是 0 的话，则可以省略： `E[0j == E[J`

| 转义序列 | 功能                           |
| -------- | ------------------------------ |
| E[nA     | 光标上移 n 行                  |
| E[nB     | 光标下移 n 行                  |
| E[nC     | 光标右移 n 个字符位置          |
| E[nD     | 光标左移 n 个字符位置          |
| E[n`     | 光标移动到字符 n 位置          |
| E[na     | 光标右移 n 个字符位置          |
| E[nd     | 光标移动到行 n 上              |
| E[ne     | 光标下移 n 行                  |
| E[nF     | 光标上移 n 行，停在行开始处    |
| E[nE     | 光标下移 n 行，停在行开始处    |
| E[y;xH   | 光标移到 x,y 位置              |
| E[H      | 光标移到屏幕左上角             |
| E[y;xf   | 光标移到位置 x,y               |
| E[nZ     | 光标后移 n 制表位              |
| E[nL     | 插入 n 条空白行                |
| E[n@     | 插入 n 个空格字符              |
| E[nM     | 删除 n 行                      |
| E[nP     | 删除 n 个字符                  |
| E[nJ     | 檫除部分或全部显示字符         |
|          | n = 0 从光标处到屏幕底部；     |
|          | n = 1 从屏幕上端到光标处；     |
|          | n = 2 屏幕上所有字符           |
| E[s      | 保存光标位置                   |
| E[nK     | 删除部分或整行：               |
|          | n = 0 从光标处到行末端         |
|          | n = 1 从行开始到光标处         |
|          | n = 2 整行                     |
| E[nX     | 删除 n 个字符                  |
| E[nS     | 向上卷屏 n 行（屏幕下移）      |
| E[nT     | 向下卷屏 n 行（屏幕上移）      |
| E[nm     | 设置字符显示属性：             |
|          | n = 0 普通属性（无属性）       |
|          | n = 1 粗（bold）               |
|          | n = 4 下划线（underscore）     |
|          | n = 5 闪烁（blink）            |
|          | n = 7 反显（reverse）          |
|          | n = 3X 设置前台显示色彩        |
|          | n = 4X 设置后台显示色彩        |
|          | X = 0 黑 black X = 1 红 red    |
|          | X = 2 绿 green X = 3 棕 brown  |
|          | X = 4 蓝 blue X = 5 紫 magenta |
|          | X = 6 青 cyan X = 7 白 white   |
|          | 使用分号可以同时设置多个属性， |
|          | 例如：E[0;1;33;40m             |


## 数据结构

```c
typedef struct console_t
{
    u32 mem_base; // 内存基地址
    u32 mem_size; // 内存大小
    u32 mem_end;  // 内存结束位置

    u32 screen;   // 当前屏幕位置
    u32 scr_size; // 屏幕内存大小

    union
    {
        u32 pos;   // 当前光标位置
        char *ptr; // 位置指针
    };
    u32 x;        // 光标坐标 x
    u32 y;        // 光标坐标 y
    u32 saved_x;  // 保存的 x
    u32 saved_y;  // 保存的 y
    u32 width;    // 屏幕宽度
    u32 height;   // 屏幕高度
    u32 row_size; // 行内存大小

    u8 state;         // 当前状态
    u32 args[ARG_NR]; // 参数
    u32 argc;         // 参数数量
    u32 ques;         

    u16 erase; // 清屏字符
    u8 style;  // 当前样式
} console_t;
```


## 相关函数

```c
// console初始化
void console_init()
{
    console_t *con = &console;
    con->mem_base = MEM_BASE; // 内存位置
    con->mem_size = (MEM_SIZE / ROW_SIZE) * ROW_SIZE; // 内存大小
    con->mem_end = con->mem_base + con->mem_size; // 内存结束位置
    con->width = WIDTH; // 宽度
    con->height = HEIGHT; // 高度
    con->row_size = con->width * 2; // 行大小
    con->scr_size = con->width * con->height * 2; // 屏幕大小

    con->erase = ERASE; // 清屏
    con->style = STYLE; // 样式
    console_clear(con); // 清屏

    device_install( // 将设备注册
        DEV_CHAR, DEV_CONSOLE,
        con, "console", 0,
        NULL, NULL, console_write);
}

// 写控制台
int console_write(console_t *con, char *buf, u32 count)
{
    bool intr = interrupt_disable(); // 禁止中断

    // console_t *con = &console;
    char ch;
    int nr = 0;
    while (nr++ < count)
    {
        ch = *buf++;
        switch (con->state)
        {
        case STATE_NOR:
            state_normal(con, ch);
            break;
        case STATE_ESC:
            state_esc(con, ch);
            break;
        case STATE_QUE:
            memset(con->args, 0, sizeof(con->args));
            con->argc = 0;
            con->state = STATE_ARG;
            con->ques = (ch == '?');
            if (con->ques)
                break;
        case STATE_ARG:
            if (!state_arg(con, ch))
                break;
        case STATE_CSI:
            state_csi(con, ch);
            break;
        default:
            break;
        }
    }
    set_cursor(con);
    // 恢复中断
    set_interrupt_state(intr);
    return nr;
}

// CSI 状态
static _inline void state_csi(console_t *con, char ch)
{
    con->state = STATE_NOR;
    switch (ch)
    {
    case 'G':
    case '`':
        if (con->args[0])
            con->args[0]--;
        set_xy(con, con->args[0], con->y);
        break;
    case 'A': // 光标上移一行或 n 行
        if (!con->args[0])
            con->args[0]++;
        set_xy(con, con->x, con->y - con->args[0]);
        break;
    case 'B':
    case 'e': // 光标下移一行或 n 行
        if (!con->args[0])
            con->args[0]++;
        set_xy(con, con->x, con->y + con->args[0]);
        break;
    case 'C':
    case 'a': // 光标右移一列或 n 列
        if (!con->args[0])
            con->args[0]++;
        set_xy(con, con->x + con->args[0], con->y);
        break;
    case 'D': // 光标左移一列或 n 列
        if (!con->args[0])
            con->args[0]++;
        set_xy(con, con->x - con->args[0], con->y);
        break;
    case 'E': // 光标下移一行或 n 行，并回到 0 列
        if (!con->args[0])
            con->args[0]++;
        set_xy(con, 0, con->y + con->args[0]);
        break;
    case 'F': // 光标上移一行或 n 行，并回到 0 列
        if (!con->args[0])
            con->args[0]++;
        set_xy(con, 0, con->y - con->args[0]);
        break;
    case 'd': // 设置行号
        if (con->args[0])
            con->args[0]--;
        set_xy(con, con->x, con->args[0]);
        break;
    case 'H': // 设置行号和列号
    case 'f':
        if (con->args[0])
            con->args[0]--;
        if (con->args[1])
            con->args[1]--;
        set_xy(con, con->args[1], con->args[0]);
        break;
    case 'J': // 清屏
        csi_J(con);
        break;
    case 'K': // 行删除
        csi_K(con);
        break;
    case 'L': // 插入行
        csi_L(con);
        break;
    case 'M': // 删除行
        csi_M(con);
        break;
    case 'P': // 删除字符
        csi_P(con);
        break;
    case '@': // 插入字符
        csi_at(con);
        break;
    case 'm': // 修改样式
        csi_m(con);
        break;
    case 'r': // 设置起始行号和终止行号
        break;
    case 's':
        save_cursor(con);
    case 'u':
        set_xy(con, con->saved_x, con->saved_y);
    default:
        break;
    }
}

// 修改样式
static _inline void csi_m(console_t *con)
{
    con->style = 0;
    for (size_t i = 0; i < con->argc; i++)
    {
        if (con->args[i] == ST_NORMAL)
            con->style = STYLE;

        else if (con->args[i] == ST_BOLD)
            con->style = BOLD;

        else if (con->args[i] == BLINK)
            con->style |= BLINK;

        else if (con->args[i] == ST_REVERSE)
            con->style = (con->style >> 4) | (con->style << 4);

        else if (con->args[i] >= 30 && con->args[i] <= 37)
            con->style = con->style & 0xF8 | (con->args[i] - 30);

        else if (con->args[i] >= 40 && con->args[i] <= 47)
            con->style = con->style & 0x8F | ((con->args[i] - 40) << 4);
    }
    con->erase = (con->style << 8) | 0x20;
}
```


## 参考文献

- 赵炯 - 《Linux内核完全注释》
- <https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_(Control_Sequence_Introducer)_sequences>


---


# 13.TTY 设备

## 命令
查看TTY设备的配置信息：
- `stty -a`


## 相关配置与定义

```makefile
$(BUILD)/kernel/tty.o \
```

- ioctl 设置进程组命令：#define TIOCSPGRP 0x5410


## 数据结构

```c
// 设备子类型
enum device_subtype_t
{
    //......
    DEV_TTY,         // TTY 设备
    //......
};

typedef enum syscall_t
{
    //......
    SYS_NR_IOCTL = 54,
    //......
} syscall_t;

typedef struct tty_t
{
    dev_t rdev; // 读设备号
    dev_t wdev; // 写设备号
    pid_t pgid; // 进程组
} tty_t;
```


## 相关函数

在
```c
keyboard_handler(int vector)
```
函数中
```c
// 通知 tty 设备处理输入字符
if (tty_rx_notify(&ch, ctrl_state, shift_state, alt_state) > 0)
        return;
// 否则压入队列
fifo_put(&fifo, ch);
if (waiter != NULL)
{
    task_unblock(waiter, EOK);
    waiter = NULL;
}
```

```c
// 发送 SIGINT 信号给前台进程组
int tty_intr()
{
    tty_t *tty = &typewriter;
    if (tty->pgid == 0)
    {
        return 0;
    }
    for (size_t i = 0; i < TASK_NR; i++)
    {
        task_t *task = task_table[i];
        if (!task || task->pgid != tty->pgid)
            continue;
        kill(task->pid, SIGINT);
    }
    return 0;
}

int tty_rx_notify(char *ch, bool ctrl, bool shift, bool alt)
{
    if (*ch == '\r')
    {
        *ch = '\n';
    }

    if (!ctrl)
    {
        return 0;
    }

    tty_t *tty = &typewriter;
    switch (*ch)
    {
    case 'c':
    case 'C':
        LOGK("CTRL + C Pressed\n");
        tty_intr();
        *ch = '\n';
        return 0;
    case 'l':
    case 'L':
        // 清除屏幕
        device_write(tty->wdev, "\x1b[2J\x1b[H\r", 7, 0, 0);
        *ch = '\r';
        return 0;
    default:
        return 1;
    }
}

int tty_read(tty_t *tty, char *buf, u32 count)
{
    return device_read(tty->rdev, buf, count, 0, 0);
}

int tty_write(tty_t *tty, char *buf, u32 count)
{
    return device_write(tty->wdev, buf, count, 0, 0);
}

int tty_ioctl(tty_t *tty, int cmd, void *args, int flags)
{
    if (cmd == TIOCSPGRP)
    {
        tty->pgid = (pid_t)args;
        return 0;
    }
    return -EINVAL;
}

int sys_stty()
{
    return -ENOSYS;
}

int sys_gtty()
{
    return -ENOSYS;
}

void tty_init()
{
    device_t *device = NULL;

    tty_t *tty = &typewriter;

    // 设置键盘为输入设备
    device = device_find(DEV_KEYBOARD, 0);
    tty->rdev = device->dev;

    // 设置控制台为输出设备
    device = device_find(DEV_CONSOLE, 0);
    tty->wdev = device->dev;

    device_install(DEV_CHAR, DEV_TTY, tty, "tty", 0, tty_ioctl, tty_read, tty_write);
}

```


## 参考文献

- <https://www.linusakesson.net/programming/tty/index.php>


---


# 14.CPU 功能检测

## CPUID

`CPUID`指令可以用于获取很多 CPU 的信息。
EFLAGS 位图：
![](./images/eflags.drawio.svg)


## 功能检测

在执行 `CPUID` 指令之前，首先应检测处理器是否支持该指令，如果 EFLAGS 的 ID 位可修改，那么表示处理器支持 `CPUID` 指令。


## 基础用法

执行 `CPUID` 指令前，将参数 `0` 传入 `EAX`，不同的参数将返回不同的信息。

### 供应商 ID

当 `EAX = 0` 时，CPUID 将返回供应商 ID 字符串到 `EBX`, `EDX` 和 `ECX`，将其写入内存将得到长度 12 的字符串，表示供应商的 ID。
典型的供应商 ID：
- #define CPUID_VENDOR_AMD "AuthenticAMD"
- #define CPUID_VENDOR_INTEL "GenuineIntel"
`EAX` 中返回最大的输入数；

### CPU 功能

使用参数 `EAX` = 1 调用 CPUID，返回一个位图存储在 `EDX` 和 `ECX` 中。注意不同品牌的 CPU 可能有不同的含义。


## 数据结构

```c
typedef struct cpu_vendor_t
{
    u32 max_value; // 4 字节
    char info[13]; // 12 字节
} _packed cpu_vendor_t;
```
其中 12 字节字符串为：
- #define CPUID_VENDOR_AMD "AuthenticAMD"
- #define CPUID_VENDOR_INTEL "GenuineIntel"

```c
typedef struct cpu_version_t
{
    u8 stepping : 4;
    u8 model : 4;
    u8 family : 4;
    u8 type : 2;
    u8 RESERVED : 2;
    u8 emodel : 4;
    u8 efamily0 : 4;
    u8 efamily1 : 4;
    u8 RESERVED : 4;

    u8 brand_index;
    u8 clflush;
    u8 max_num;
    u8 apic_id;

    // ECX;
    u8 SSE3 : 1;       // 0
    u8 PCLMULQDQ : 1;  // 1
    u8 DTES64 : 1;     // 2
    u8 MONITOR : 1;    // 3
    u8 DS_CPL : 1;     // 4
    u8 VMX : 1;        // 5
    u8 SMX : 1;        // 6
    u8 EIST : 1;       // 7
    u8 TM2 : 1;        // 8
    u8 SSSE3 : 1;      // 9
    u8 CNXT_ID : 1;    // 10
    u8 SDBG : 1;       // 11
    u8 FMA : 1;        // 12
    u8 CMPXCHG16B : 1; // 13
    u8 xTPR : 1;       // 14
    u8 PDCM : 1;       // 15
    u8 RESERVED : 1;   // 16
    u8 PCID : 1;       // 17
    u8 DCA : 1;        // 18
    u8 SSE4_1 : 1;     // 19
    u8 SSE4_2 : 1;     // 20
    u8 x2APIC : 1;     // 21
    u8 MOVBE : 1;      // 22
    u8 POPCNT : 1;     // 23
    u8 TSCD : 1;       // 24
    u8 AESNI : 1;      // 25
    u8 XSAVE : 1;      // 26
    u8 OSXSAVE : 1;    // 27
    u8 AVX : 1;        // 28
    u8 F16C : 1;       // 29
    u8 RDRAND : 1;     // 30
    u8 RESERVED : 1;   // 31

    // EDX
    u8 FPU : 1;      // 0 x87 FPU on Chip
    u8 VME : 1;      // 1 Virtual-8086 Mode Enhancement
    u8 DE : 1;       // 2 Debugging Extensions
    u8 PSE : 1;      // 3 Page Size Extensions
    u8 TSC : 1;      // 4 Time Stamp Counter
    u8 MSR : 1;      // 5 RDMSR and WRMSR Support
    u8 PAE : 1;      // 6 Physical Address Extensions
    u8 MCE : 1;      // 7 Machine Check Exception
    u8 CX8 : 1;      // 8 CMPXCHG8B Inst.
    u8 APIC : 1;     // 9 APIC on Chip
    u8 RESERVED : 1; // 10
    u8 SEP : 1;      // 11 SYSENTER and SYSEXIT
    u8 MTRR : 1;     // 12 Memory Type Range Registers
    u8 PGE : 1;      // 13 PTE Global Bit
    u8 MCA : 1;      // 14 Machine Check Architecture
    u8 CMOV : 1;     // 15 Conditional Move/Compare Instruction
    u8 PAT : 1;      // 16 Page Attribute Table
    u8 PSE36 : 1;    // 17 Page Size Extension
    u8 PSN : 1;      // 18 Processor Serial Number
    u8 CLFSH : 1;    // 19 CLFLUSH instruction
    u8 RESERVED : 1; // 20
    u8 DS : 1;       // 21 Debug Store
    u8 ACPI : 1;     // 22 Thermal Monitor and Clock Ctrl
    u8 MMX : 1;      // 23 MMX Technology
    u8 FXSR : 1;     // 24 FXSAVE/FXRSTOR
    u8 SSE : 1;      // 25 SSE Extensions
    u8 SSE2 : 1;     // 26 SSE2 Extensions
    u8 SS : 1;       // 27 Self Snoop
    u8 HTT : 1;      // 28 Multi-threading
    u8 TM : 1;       // 29 Therm. Monitor
    u8 RESERVED : 1; // 30
    u8 PBE : 1;      // 31 Pend. Brk. EN.
} _packed cpu_version_t;
```


## 相关函数

```c
// 检测是否支持 cpuid 指令
bool cpu_check_cpuid()
{
    bool is_supported;
    asm volatile(
        "pushfl \n"                // 保存 eflags
        "pushfl \n"                // 复制 eflags
        "xor $0x00200000, (%%esp)\n" // 翻转 ID 位
        "popfl \n"                 // 将修改后的值写回 eflags

        "pushfl \n"                // 再次获取 eflags
        "pop %%eax \n"             // 将 eflags 存入 eax
        "xor (%%esp), %%eax \n"    // 比较前后的 ID 位
        "and $0x00200000, %%eax \n" // 提取 ID 位
        "shr $21, %%eax \n"        // 右移 21 位，判断是否支持

        "popfl \n"                 // 恢复原始 eflags
        : "=a"(is_supported));     // 将结果存入 is_supported
    return is_supported;
}

// 获取 CPU 供应商 ID 字符串
void cpu_vendor_id(cpu_vendor_t *vendor_info)
{
    u32 *info = (u32 *)vendor_info->info; // 提取 info 字段的指针
    asm volatile(
        "cpuid \n"
        : "=a"(info[0]),  // EAX 寄存器值
          "=b"(info[1]),  // EBX 寄存器值
          "=d"(info[2]),  // EDX 寄存器值
          "=c"(info[3])   // ECX 寄存器值
        : "a"(0));        // CPUID 功能号 0
    vendor_info->info[12] = 0; // 确保字符串末尾的终止符
}

// 获取 CPU 版本信息
void cpu_version(cpu_version_t *version_info)
{
    u32 *info = (u32 *)version_info;
    asm volatile(
        "cpuid \n"
        : "=a"(info[0]),  // EAX 寄存器值
          "=b"(info[1]),  // EBX 寄存器值
          "=c"(info[2]),  // ECX 寄存器值
          "=d"(info[3])   // EDX 寄存器值
        : "a"(1));        // CPUID 功能号 1
}

```

## 参考文献

- https://wiki.osdev.org/CPUID
- Intel® 64 and IA-32 Architectures Software Developer's Manual


---


# 15.FPU 浮点运算单元

## FPU 控制

- CR0.EM (bit 2)
- CR0.ET (bit 4)
- CR0.NE (bit 5)
- CR0.TS (bit 3)
- CR0.MP (bit 1)
- CR4.OSFXSR (bit 9)
- CR4.OSXMMEXPT (bit 10)
- CR4.OSXSAVE (bit 18)


## FPU 状态

可使用 `fnsave` 和 `frstor` 指令来保存和恢复 FPU 状态。


## CR0 寄存器状态

```c
enum
{
    CR0_PE = 1 << 0,  // Protection Enable 启用保护模式
    CR0_MP = 1 << 1,  // Monitor Coprocessor
    CR0_EM = 1 << 2,  // Emulation 启用模拟，表示没有 FPU
    CR0_TS = 1 << 3,  // Task Switch 任务切换，延迟保存浮点环境
    CR0_ET = 1 << 4,  // Extension Type 保留
    CR0_NE = 1 << 5,  // Numeric Error 启用内部浮点错误报告
    CR0_WP = 1 << 16, // Write Protect 写保护（禁止超级用户写入只读页）帮助写时复制
    CR0_AM = 1 << 18, // Alignment Mask 对齐掩码
    CR0_NW = 1 << 29, // Not Write-Through 不是直写
    CR0_CD = 1 << 30, // Cache Disable 禁用内存缓冲
    CR0_PG = 1 << 31, // Paging 启用分页
};
```


## 相关定义

- 协处理器段超限：#define INTR_OVER 9 


## 数据结构

```c
typedef enum task_flag_t
{
    TASK_FPU_USED = 1, // FPU 是否用过
    TASK_FPU_ENABLED = 2, // FPU 是否有效
} task_flag_t;

// FPU 状态数据结构 存储在 128 个字节中
typedef struct fpu_t
{
    u16 control;
    u16 RESERVED;
    u16 status;
    u16 RESERVED;
    u16 tag;
    u16 RESERVED;
    u32 fip0;
    u32 fop0;
    u32 fdp0;
    u32 fdp1;
    u8 regs[80];
} _packed fpu_t;
```

## 相关函数

```c
// 验证系统是否支持 FPU
bool fpu_check()
{
    cpu_version_t version;
    cpu_version(&version);
    if (!version.FPU)
        return false;

    u32 status_word = 0x55AA;
    u32 result;
    asm volatile(
        "movl %%cr0, %%edx\n" // 读取 cr0 寄存器
        "andl %%ecx, %%edx\n" // 清除 EM 和 TS 标志位以启用 FPU
        "movl %%edx, %%cr0\n" // 更新 cr0 寄存器

        "fninit\n"    // 初始化 FPU
        "fnstsw %1\n" // 保存状态字到 status_word

        "movl %1, %%eax\n" // 将状态字载入 eax
        : "=a"(result)     // 将 eax 保存到 result
        : "m"(status_word), "c"(~(CR0_EM | CR0_TS)));
    return result == 0; // 如果状态字为 0，则表示 FPU 可用
}

// 获取 cr0 寄存器的值
u32 get_cr0()
{
    u32 cr0;
    asm volatile("movl %%cr0, %0" : "=r"(cr0)); // 将 cr0 的值保存到 cr0 变量中
    return cr0;
}

// 设置 cr0 寄存器
void set_cr0(u32 cr0)
{
    asm volatile("movl %0, %%cr0" ::"r"(cr0)); // 将 cr0 的值写入寄存器
}

// 激活 FPU
void fpu_enable(task_t *task)
{
    // LOGK("激活 FPU...\n");

    set_cr0(get_cr0() & ~(CR0_EM | CR0_TS));

    // 如果当前任务和上次使用 FPU 的任务相同，则无需恢复浮点环境
    if (last_fpu_task == task)
        return;

    // 如果上一个任务使用了 FPU，则保存它的浮点环境
    if (last_fpu_task && (last_fpu_task->flags & TASK_FPU_ENABLED))
    {
        assert(last_fpu_task->fpu);
        asm volatile("fnsave (%%eax)" ::"a"(last_fpu_task->fpu));
        last_fpu_task->flags &= ~TASK_FPU_ENABLED;
    }

    last_fpu_task = task;

    // 如果当前任务已经有 FPU 环境，则恢复它
    if (task->fpu)
    {
        asm volatile("frstor (%%eax)" ::"a"(task->fpu));
    }
    else
    {
        // 否则，初始化一个新的浮点环境
        asm volatile(
            "fnclex\n"
            "fninit\n");

        LOGK("为任务 0x%p 创建 FPU 状态\n", task);
        task->fpu = (fpu_t *)kmalloc(sizeof(fpu_t));
        task->flags |= (TASK_FPU_ENABLED | TASK_FPU_USED);
    }
}

// 禁用 FPU
void fpu_disable(task_t *task)
{
    set_cr0(get_cr0() | (CR0_EM | CR0_TS));
}

// FPU 异常处理函数
void fpu_handler(int vector)
{
    // LOGK("处理 FPU 异常...\n");
    assert(vector == INTR_NM);
    task_t *task = running_task();
    assert(task->uid);

    fpu_enable(task);
}

// 初始化 FPU
void fpu_init()
{
    LOGK("初始化 FPU...\n");

    bool has_fpu = fpu_check();
    last_fpu_task = NULL;
    assert(has_fpu);

    if (has_fpu)
    {
        // 设置 FPU 异常处理程序
        set_exception_handler(INTR_NM, fpu_handler);
        // 配置 CR0 寄存器
        set_cr0(get_cr0() | CR0_EM | CR0_TS | CR0_NE);
    }
    else
    {
        LOGK("系统不支持 FPU...\n");
    }
}

```


## 参考文献

- <https://wiki.osdev.org/Fpu>
- <https://www.felixcloutier.com/x86/fsave:fnsave>
- <https://www.felixcloutier.com/x86/frstor>


---


# 16.ISA 总线

## ISA DMA 要点

Direct Memory Access 直接存储访问
ISA DMA 的要点：
- ISA DMA 与 PCI 总线控制 DMA 不一样;
- ISA DMA 通道 1、2 和 3 可用于 8 位传输到 ISA 外设;
- ISA DMA 通道 5、6 和 7 可用于向 ISA 外设的 16 位传输;
- 传输不能跨越物理 64KB 边界，并且不能大于 64KB;
- 传输必须在物理上是连续的，并且只能以最低的 16MB 物理内存为目标;
- ISA DMA 慢：理论上是 4.77 MB/s，但由于 ISA 总线协议，更像是 400 KB/s;
- ISA DMA 释放了 CPU 资源，但是给内存总线增加了非常重的负载。
注:
- Sound Blaster 和 Sound Blaster PRO 只支持 8 位 DMA;
- Sound Blaster 16+ 支持 8 位和 16 位 DMA;
- 软盘控制器只支持 8 位 DMA，并且硬连接使用 DMA 通道 2。


## 参考文献

- <https://wiki.osdev.org/ISA>
- <http://wikipedia.org/wiki/Industry_Standard_Architecture>
- <https://wiki.osdev.org/ISA_DMA>
- <http://www.brokenthorn.com/Resources/OSDev21.html>


---


# 17.声霸卡驱动

## 数字信号处理器 (Digital Signal Processor, DSP)

Sound Blaster 16 内置的 DSP 支持播放和录制 8 位和 16 位 PCM 编码的音频，以及播放其他几种格式( ADPCM 等)。I/O 寄存器基地址可以通过 PCI 型号的 PCI 总线找到，或者通过向几个常见 I/O 端口地址之一 (`0x220`、`0x240` 等) 发出 Get Version 命令来检测旧的 ISA Sound Blaster 的存在，并等待其响应。

| 端口号 | 描述                       |
| ------ | -------------------------- |
| 0x224  | DSP 混合器端口             |
| 0x225  | DSP 混合器数据端口         |
| 0x226  | DSP 重置                   |
| 0x22A  | DSP 读                     |
| 0x22C  | DSP 写                     |
| 0x22E  | DSP 读状态(相应 8 位 中断) |
| 0x22F  | DSP 十六位 中断相应        |

| DSP 写命令 | 描述               |
| ---------- | ------------------ |
| 0x40       | 设置时间常数       |
| 0x41       | 设置输出采样率     |
| 0xD1       | 扬声器开           |
| 0xD3       | 扬声器关           |
| 0xD0       | 停止播放 8 位通道  |
| 0xD4       | 恢复播放 16 位通道 |
| 0xD5       | 停止播放 8 位通道  |
| 0xD6       | 恢复播放 16 位通道 |
| 0xE1       | 获取 DSP 版本      |

| 混合器端口命令 | 描述     |
| -------------- | -------- |
| 0x22           | 主音量   |
| 0x80           | 设置中断 |


## 复位 DSP(检测 DSP)

1. 发送 1 到 DSP 复位端口
2. 等待 3 微秒
3. 发送 0 到 DSP 复位端口
4. 现在应该在 DSP 读端口 0xAA


## 中断设置

- 发送 0x80 到 混合器端口
- 发送 IRQ 值到混合器数据端口
    - 0x01 = IRQ 2
    - 0x02 = IRQ 5
    - 0x04 = IRQ 7
    - 0x08 = IRQ 10
- 通常使用 IRQ 5，也可以读取此端口以获得实际的 IRQ
```c
static void sb_intr_irq(sb_t *sb)
{
    outb(SB_MIXER, 0x80);
    u8 data = inb(SB_MIXER_DATA);
    if (data != 2)
    {
        outb(SB_MIXER, 0x80);
        outb(SB_MIXER_DATA, 0x2);
    }
}
```


## DMA 编程

通过通道 1(通道号为 1) 对 8 位传输编程:
- 通过写入端口 0x0A 值 0x05 (通道号 + 0x04) 禁用通道
- 将值写入触发器端口 0x0C
    - (任意值，例如 1)
- 发送传输模式到 0x0B 
    - ((单模式为 0x48 / 自动模式为 0x58) + 通道号)
- 将页索引发送到 0x83 (通道 1 的页端口)
    - 例如，如果在 0x100450 处有声音数据，则页索引为 0x10
    - 与分页机制有所不同？确实不同，这里相当于 64K 分段
- 将低位发送到端口 0x02
    - 例如(参见上面) 是 0x50
- 发送高位到端口 0x02
    - 例如(参见上面) 是 0x04
- 发送低字节长度的数据到端口 0x03 (通道 1 的计数端口)
    - 例如，如果长度为 0x0FFF，则发送0xFF
- 将高字节长度的数据发送到端口 0x03(通道 1 的计数端口)
    - 例如，如果长度为 0x0FFF，则发送0x0F
- 通过将通道号写入端口 0x0A 来启用通道
通过通道 5 编程 16 位传输(通道号也为1):
- 通过写入端口 0xD4 值 0x05(通道号+ 0x04) 来禁用通道
- 将值写入触发器端口 0xD8(任意值，例如 1)
- 发送传输模式到0xD6 (单模式为 0x48 /自动模式为 0x58 + 通道号)
- 将页码发送到0x8B(通道 5 的页端口)
    - 如果在 0x100450 处有声音数据，则页号为 0x10
- 发送低位位到端口 0xC4
    - 例如(参见上面) 是 0x50
- 发送高位到端口0xC4
    - 例如(参见上面) 是 0x04
- 发送低字节长度的数据到端口 0xC6(通道 5 的计数端口)
    - 例如，如果长度为 0x0FFF，则发送0xFF
- 将高字节长度的数据发送到端口 0xC6(通道 5 的计数端口)
    - 例如，如果长度为 0x0FFF，则发送0x0F
    通过将通道号写入端口0xD4来启用通道


## 写入传输模式到 DSP

通常值为 0xB0 表示 16 位播放声音，0xC0 表示 8 位播放声音

- 位 0： 0
- 位 1：
    - 0 = FIFO off
    - 1 = FIFO on
- 位 2： 0
- 位 3：
    - 0 = 播放
    - 1 = 录音
- 位 4 ~ 7：
    - 0xB = 16 位传输
    - 0xC = 8 位传输


## 写入声音数据类型到 DSP

在写入传输模式后，必须写输入声音数据的类型。

| 位    | 描述                   |
| ----- | ---------------------- |
| 0 ~ 3 | 0                      |
| 4     | 0 无符号 <br> 1 有符号 |
| 5     | 0 单声道 <br> 1 立体声 |
| 6 ~ 7 | 0                      |


## 播放声音

1. 重置 DSP
2. 将声音数据载入内存
3. 设置主音量
4. 打开扬声器
5. 程序 ISA DMA 传输
6. 设置时间常数
    1. 注意，Sound Blaster 16 能够使用采样率而不是时间常数，使用0x41而不是0x40命令。
    2. 可以这样计算时间常数: 时间常数 = 65536 - (256000000 / ( 通道 * 采样率 ))
7. 设定输出采样率
8. 写入传输模式到 DSP
9. 写入声音数据类型
10. 写数据长度到 DSP(低字节/高字节)  
    - 对于双声道 16 位数据需要将长度 / 4，这里 4 是单帧采样数据的长度；
    - 必须计算 长度 - 1，例如，如果真实长度是 0x0FFF，那么需要发送 0xFE 和 0x0F


## 虚拟机支持

### qemu 支持

为使 qemu 支持声霸卡，在启动时添加如下选项：
```makefile
QEMU+= -audiodev pa,id=snd # Pause Audio backend
QEMU+= -device sb16,audiodev=snd # Sound Blaster 16
```

### VMWare 支持

为使 VMWare 的支持，修改 .vmx 文件，添加如下内容：
```ini
sound.present = "TRUE"
sound.virtualDev = "sb16"
sound.opl3.enabled = "TRUE"
sound.autodetect = "TRUE"
sound.baseAddr = "0x220"
sound.dma16 = "5"
sound.dma8 = "1"
sound.irq = "5"
```

### bochs

bochs 默认不支持，需打开编译选项 `--enable-sb16`；


## 音频文件生成

为了使解码方式简单，可以直接生成 PCM(Pulse Code Modulation) 编码的 wave 文件，可以直接写入声卡播放。
可以使用 `ffmpeg` 对音频文件进行转码：
- 单声道无符号 8 位
  ffmpeg -i music.mp3 -ac 1 -ar 44100 -acodec pcm_u8 -y mono.wav
- 双声道有符号 16 位
  ffmpeg -i music.mp3 -ac 2 -ar 44100 -acodec pcm_s16le -y stereo.wav

其中：
- -ac 1：声道数
  -ar 44100：采样率
  -acodec pcm_u8：格式


## 相关配置

```makefile
BUILTIN_APPS := \
	$(BUILD)/builtin/player.out \
```

```makefile
$(BUILD)/kernel.raw.bin: \
	$(BUILD)/kernel/sb16.o \
```


## 相关定义

- SB16 声卡：#define IRQ_SB16 5


## 数据结构

```c++
// WAVE file header format
typedef struct wav_header_t
{
    u8 riff[4];       // RIFF string
    u32 chunksize;    // 32 + subchunksize
    u8 wave[4];       // WAVE
    u8 fmt[4];        // ASCII码表示的 fmt (0x666d7420)，最后一个是空格
    u32 format;       // 本块数据的大小，(对于PCM, 值为16)
    u16 type;         // 格式 1-PCM, 3- IEEE float ...
    u16 channels;     // 通道数
    u32 sample_rate;  // 采样率 sampling rate (blocks per second)
    u32 byterate;     // 码率 SampleRate * NumChannels * BitsPerSample/8
    u16 block_align;  // NumChannels * BitsPerSample/8
    u16 bits;         // 位数 8 bits, 16 bits
    u8 subchunk[4];   // DATA 或 FLLR
    u32 subchunksize; // 数据大小
} _packed wav_header_t;
```

```c
typedef enum sb16_cmd_t
{
    SB16_CMD_ON = 1,   // 声卡开启
    SB16_CMD_OFF,      // 声卡关闭
    SB16_CMD_MONO8,    // 八位单声道模式
    SB16_CMD_STEREO16, // 16位立体声模式
    SB16_CMD_VOLUME,   // 设置音量
} sb16_cmd_t;
```
```c
typedef struct sb_t
{
    task_t *waiter;
    lock_t lock;
    char *addr; // DMA 地址
    u8 mode;    // 模式
    u8 channel; // DMA 通道
} sb_t;
```


## 相关函数

```c
int main(int argc, char const *argv[])
{
    // 如果没有传递音频文件路径作为参数，程序立即退出。
    if (argc < 2)
    {
        return EOF;
    }

    fd_t sb16 = 0;
    fd_t fd = 0;
    int ret = EOF;

    fd = open((char *)argv[1], O_RDONLY, 0);

    // 文件无法打开
    if (fd < 0)
    {
        printf("File %s not exists.\n", argv[1]);
        return EOF;
    }

    wav_header_t header;
    // 读取 WAV 文件头信息并进行检查
    ret = read(fd, (char *)&header, sizeof(header));
    // 检查文件格式是否为 WAVE
    if (ret != sizeof(header) || memcmp(header.wave, "WAVE", 4))
    {
        printf("Only wave files are supported\n");
        ret = -1; // 不支持
        goto rollback;
    }
    // 检查音频文件是否为 PCM 格式
    if (header.type != TYPE_PCM)
    {
        printf("Only pcm format is supported\n");
        ret = -1; // 不支持
        goto rollback;
    }

    if (header.sample_rate != 44100)
    {
        printf("support sample != 44100 Hz.\n");
        ret = -1; // 不支持
        goto rollback;
    }
    // 检查音频文件的声道和位深度
    // 支持的格式为 8 位单声道（MONO8）或 16 位立体声（STEREO16）。
    u8 mode;
    if (header.bits == 8 && header.channels == 1)
    {
        mode = SB16_CMD_MONO8;
    }
    else if (header.bits == 16 && header.channels == 2)
    {
        mode = SB16_CMD_STEREO16;
    }
    else
    {
        printf("Cannot play channels %d and bits %d\n",
               header.channels,
               header.bits);
        ret = -1;
        goto rollback;
    }

    // 尝试打开 /dev/sb16 声卡设备文件
    sb16 = open("/dev/sb16", O_WRONLY, 0);
    if (sb16 < 0)
    {
        printf("Can't open sb16\n");
        goto rollback;
    }

    ioctl(sb16, SB16_CMD_ON, 0); // 开启声卡
    ioctl(sb16, mode, 0); // 设置播放模式（单声道或立体声）
    ioctl(sb16, SB16_CMD_VOLUME, 0xff); 设置音量

    // 使用循环从文件读取数据并将其写入声卡设备进行播放
    // 当读取到文件尾部时（read 返回负数），跳出循环
    while (1)
    {
        int len = read(fd, buf, BUFLEN);
        if (len < 0)
        {
            break;
        }
        write(sb16, buf, len);
    }

rollback:
    // 清理资源
    // 如果文件 fd 被打开，关闭它
    if (fd > 0)
    {
        close(fd);
    }
    // 如果声卡设备 sb16 被打开，关闭它并停用声卡
    if (sb16 > 0)
    {
        ioctl(sb16, SB16_CMD_OFF, 0);
        close(sb16);
    }
    return 0;
}
```

```c
dev_init()
```
函数中
```c
assert(mkdir("/dev/net", 0755) == EOK);
    for (size_t i = 0; true; i++)
    {
        device = device_find(DEV_NETIF, i); // 找到声霸卡
        if (!device)
        {
            break;
        }
        sprintf(name, "/dev/net/%s", device->name); // 写入目录
        mknod(name, IFSOCK | 0400, device->dev);
    }
```
```c
static void sb_handler(int vector)
{
    send_eoi(vector);
    sb_t *sb = &sb16;

    inb(SB_INTR16);

    u8 state = inb(SB_STATE);

    LOGK("sb16 handler state 0x%X...\n", state);
    if (sb->waiter)
    {
        task_unblock(sb->waiter, EOK);
        sb->waiter = NULL;
    }
}

static void sb_reset(sb_t *sb)
{
    outb(SB_RESET, 1);
    sleep(1);
    outb(SB_RESET, 0);
    u8 state = inb(SB_READ);
    LOGK("sb16 reset state 0x%x\n", state);
}

static void sb_intr_irq(sb_t *sb)
{
    outb(SB_MIXER, 0x80);
    u8 data = inb(SB_MIXER_DATA);
    if (data != 2)
    {
        outb(SB_MIXER, 0x80);
        outb(SB_MIXER_DATA, 0x2);
    }
}

static void sb_out(u8 cmd)
{
    while (inb(SB_WRITE) & 128)
        ;
    outb(SB_WRITE, cmd);
}

static void sb_turn(sb_t *sb, bool on)
{
    if (on)
        sb_out(CMD_ON);
    else
        sb_out(CMD_OFF);
}

static u32 sb_time_constant(u8 channels, u16 sample)
{
    return 65536 - (256000000 / (channels * sample));
}

static void sb_set_volume(u8 level)
{
    LOGK("set sb16 volume to 0x%02X\n", level);
    outb(SB_MIXER, 0x22);
    outb(SB_MIXER_DATA, level);
}

int sb16_ioctl(sb_t *sb, int cmd, void *args, int flags)
{
    switch (cmd)
    {
    case SB16_CMD_ON:
        sb_reset(sb);    // 复位 DSP
        sb_intr_irq(sb); // 设置中断
        sb_out(CMD_ON);  // 打开声霸卡
        return EOK;
    case SB16_CMD_OFF:
        sb_out(CMD_OFF); // 关闭声霸卡
        return EOK;
    case SB16_CMD_MONO8:
        sb->mode = MODE_MONO8;
        sb->channel = 1;
        isa_dma_reset(sb->channel);
        return EOK;
    case SB16_CMD_STEREO16:
        sb->mode = MODE_STEREO16;
        sb->channel = 5;
        isa_dma_reset(sb->channel);
        return EOK;
    case SB16_CMD_VOLUME:
        sb_set_volume((u32)args & 0xff);
        return EOK;
    default:
        break;
    }
    return -EINVAL;
}

int sb16_write(sb_t *sb, char *data, size_t size)
{
    lock_acquire(&sb->lock);
    assert(size <= DMA_BUF_SIZE);
    memcpy(sb->addr, data, size);

    isa_dma_mask(sb->channel, false);

    isa_dma_addr(sb->channel, sb->addr);
    isa_dma_size(sb->channel, size);

    // 设置采样率
    sb_out(CMD_SOSR);                  // 44100 = 0xAC44
    sb_out((SAMPLE_RATE >> 8) & 0xFF); // 0xAC
    sb_out(SAMPLE_RATE & 0xFF);        // 0x44

    if (sb->mode == MODE_MONO8)
    {
        isa_dma_mode(sb->channel, DMA_MODE_SINGLE | DMA_MODE_WRITE);
        sb_out(CMD_SINGLE_OUT8);
        sb_out(MODE_MONO8);
    }
    else
    {
        isa_dma_mode(sb->channel, DMA_MODE_SINGLE | DMA_MODE_WRITE);
        sb_out(CMD_SINGLE_OUT16);
        sb_out(MODE_STEREO16);
        size >>= 2; // size /= 4
    }

    sb_out((size - 1) & 0xFF);
    sb_out(((size - 1) >> 8) & 0xFF);

    isa_dma_mask(sb->channel, true);

    assert(sb->waiter == NULL);
    sb->waiter = running_task();
    assert(task_block(sb->waiter, NULL, TASK_BLOCKED, TIMELESS) == EOK);

rollback:
    lock_release(&sb->lock);
    return size;
}

void sb16_init()
{
    LOGK("Sound Blaster 16 init...\n");

    sb_t *sb = &sb16;

    sb->addr = (char *)DMA_BUF_ADDR;
    sb->mode = MODE_STEREO16;
    sb->channel = 5;
    lock_init(&sb->lock);

    set_interrupt_handler(IRQ_SB16, sb_handler);
    set_interrupt_mask(IRQ_SB16, true);

    device_install(DEV_CHAR, DEV_SB16, sb, "sb16", 0, sb16_ioctl, NULL, sb16_write);
}
```


## 参考文献

- <https://wiki.osdev.org/Sound_Blaster_16>
- <https://www.qemu.org/docs/master/system/qemu-manpage.html>
- <https://virtuallyfun.com/2014/06/06/soundblaster-support-on-vmware-player/>
- <https://bochs.sourceforge.io/doc/docbook/development/sb16-emulation-basics.html>
- <https://ffmpeg.org/ffmpeg.html#Options>


---


# 18.软盘驱动

## 软盘概述

### CHS 和 LBA

软盘驱动器使用 CHS 寻址，LBA 寻址更逻辑，转换公式为：
- CYL = LBA / (HPC * SPT)
- HED = (LBA % (HPC *SPT)) / SPT
- SEC = (LBA % (HPC *SPT)) % SPT + 1
- LBA = (CYL * HPC + HEAD) * SPT + SEC - 1
其中：
- CYL：柱面数
- HED：磁头数
- SEC：扇区数
- LBA：逻辑块地址
- HPC：Head Per Cylinder 每柱面磁头数
- SPT：Sector Per Track 每磁道扇区数

### DMA 数据传输

软盘通常使用 ISA DMA (这与 PCI BusMastering DMA 不同)来进行数据传输。
软盘硬连接到 DMA 通道 2。另一种进行数据传输的方式被称为 **PIO模式**。要进行 DMA 数据传输：
- 设置 DMA 通道 2(如 DMA 文章中所述)
- 设置总传输字节数 - 1
- 目标缓冲区物理地址和传输方向
* 如果需要的话，则初始化/重置控制器(见下文)
* 如果需要的话，还需要选择驱动器(见下文)
* 使用 Specify 设置用于 DMA 的软驱控制器
* 找到正确的柱面（找柱面就是寻道）
* 发出感知中断命令
* 然后发出标准的读/写命令
* 数据传输是无形的
* 当传输完成时，控制器将发送一个 IRQ6 中断
* 然后读取 **结果** 字节，看是否有任何错误。


## CMOS 0x10

这个寄存器包含操作系统可能发现的一些有用的 CMOS 值。它描述了可能连接到系统的两个软盘驱动器的 **类型**。高位部分描述主总线上的 **主软驱**，而低位部分描述主总线上的 **从软驱**；
每个4位，描述了相关联的软驱类型:
| 值  | 类型                 |
| --- | -------------------- |
| 0x0 | 没有驱动器           |
| 0x1 | 360 KB 5.25 寸驱动器 |
| 0x2 | 1.2 MB 5.25 寸驱动器 |
| 0x3 | 720 KB 3.5 寸驱动器  |
| 0x4 | 1.44 MB 3.5 寸驱动器 |
| 0x5 | 2.88 MB 3.5 寸驱动器 |
- 0 ~ 3 位表示从软盘类型；
- 4 ~ 7 位表示主软盘类型；


## 寄存器

软盘控制器通过 9 个寄存器编程，可通过 IO 端口 0x3F0 ~ 0x3F7 访问。使用标准的 `outb` 和 `inb` 命令来访问寄存器。
软盘寄存器的基本集合可在以下枚举中找到:
```c++
enum FloppyRegisters
{
    STATUS_REGISTER_A                = 0x3F0, // read-only
    STATUS_REGISTER_B                = 0x3F1, // read-only
    DIGITAL_OUTPUT_REGISTER          = 0x3F2,
    TAPE_DRIVE_REGISTER              = 0x3F3,
    MAIN_STATUS_REGISTER             = 0x3F4, // read-only
    DATARATE_SELECT_REGISTER         = 0x3F4, // write-only
    DATA_FIFO                        = 0x3F5,
    DIGITAL_INPUT_REGISTER           = 0x3F7, // read-only
    CONFIGURATION_CONTROL_REGISTER   = 0x3F7  // write-only
};
```
所有命令、参数信息、结果码和硬盘数据传输都通过 FIFO 接口。MSR 包含 **繁忙** 位标志，必须在通过 FIFO 读取/写入每个字节之前检查。DOR 控制软驱电机，软驱选择，并复位。其他寄存器包含的信息很少，通常访问的也很少。
注：IO 端口 0x3F6 是 ATA(硬盘) 备用状态寄存器，不被任何软驱控制器使用。
如上所述，最常见的控制器芯片有3种模式，寄存器中的许多位标志根据模式不同而不同(或相反)，然而，所有重要的寄存器和位标志在模式之间保持相同。

### TDR 磁带驱动寄存器 

磁带驱动器寄存器 (TDR, Tape Drive Register) 是一个读写寄存器，用于磁带支持分配，在所有模式下都是相同的。两个最低有效位形成 1 到 3 之间的数字(0 是无效值，驱动器 0 可能不被选择)，将磁带支持分配给四个驱动器中的一个特定驱动器。

### DOR 数字输出寄存器

数字输出端口 DOR (数字控制端口) 是一个 8 位寄存器，它控制驱动器马达开启、驱动器选择、启动/复位 FDC 以及允许/禁止 DMA 及中 断请求。
| 助记符      | 位   | 值   | 功能                           |
| ----------- | ---- | ---- | ------------------------------ |
| MOTD        | 7    | 0x80 | 驱动器 3 马达开启              |
| MOTC        | 6    | 0x40 | 驱动器 2 马达开启              |
| MOTB        | 5    | 0x20 | 驱动器 1 马达开启              |
| MOTA        | 4    | 0x10 | 驱动器 0 马达开启              |
| IRQ         | 3    | 8    | 允许中断和 DMA                 |
| RESET       | 2    | 4    | 0 = 进入重置模式, 1 = 常规操作 |
| DSEL1 and 0 | 0, 1 | 3    | 选择驱动器                     |

### MSR 主状态寄存器 (只读)

FDC 的主状态寄存器也是一个 8 位寄存器，用于反映软盘控制器 FDC 和软盘驱动器 FDD 的基本状态。通常，在 CPU 向 FDC 发送命令之前或从 FDC 获取操作结果之前，都要读取主状态寄存器的状态位，以判别当前 FDC 数据寄存器是否就绪，以及确定数据传送的方向。
| 助记  | 位  | 值   | 功能                     |
| ----- | --- | ---- | ------------------------ |
| READY | 7   | 0x80 | 数据就绪 (RQM)           |
| DIO   | 6   | 0x40 | 表示传输方向， 1:读 0:写 |
| NDMA  | 5   | 0x20 | 表示非 DMA 方式          |
| BUSY  | 4   | 0x10 | 命令忙 (CB)              |
| ACTD  | 3   | 8    | 驱动器 3 寻道（忙）      |
| ACTC  | 2   | 4    | 驱动器 2 寻道            |
| ACTB  | 1   | 2    | 驱动器 1 寻道            |
| ACTA  | 0   | 1    | 驱动器 0 寻道            |
两个重要的位是 RQM 和 DIO。
RQM 它是在可以(或必要)从 FIFO 端口读/写数据时设置的
NDMA 标志着命令 **执行阶段** 的结束和 **结果阶段** 的开始。
应检查 DIO 和 BUSY 以验证正确的命令终止 (**结果阶段** 的结束和 **命令阶段** 的开始)

### CCR 和 DSR

配置控制寄存器 (CCR, Configuration Control Register) 和 数据速率选择寄存器 (DSR Datarate Select Register)。
- DSR 的低 2 位与 CCR 相匹配，设置其中一个就会设置另一个
- DSR 和 CCR 的高 6 位默认为 0，并且可以始终安全地设置为 0
- 而且 DSR 和 CCR 中的一个或另一个在任何现代系统中都可以被忽略


### 数据寄存器

FDC 的数据端口对应多个寄存器 (只写型命令寄存器和参数寄存器、只读型结果寄存器) ，但任一时刻只能有一个寄存器出现在数据端口 0x3F5。在访问只写型寄存器时，主状态控制的 DIO 方向位必须为 0 (CPU -> FDC)，访问只读型寄存器时则反之。在读取结果时只有在 FDC 不忙之后才算读完结果，通常结果数据最多有 7 个字节。

### 数字输入寄存器

数字输入寄存器 (DIR, Digital Input Register) 只有第 7 位对软盘有效，用来表示盘片更换状态。其余七位用于硬盘
控制器接口。

### 状态寄存器

有 3 个寄存器保存关于最后遇到的错误的信息，ST0 寄存器信息与大多数命令的结果字节一起传递回来。读/写命令的结果字节中返回 ST1 和 ST2 信息。也可以使用 Dumpreg 命令检索它们。

**ST0**
顶部 2 位(值=0xC0) 在复位过程后设置，轮询开启。在任何其他时间设置的任何一位都是错误指示。第 5 位(值=0x20) 在每次重新校准、寻道或隐含寻道之后设置，其他的部分是没有用的。

**ST1**
ST1 寄存器提供了更多关于读/写操作期间错误的细节。

如果软盘上的扇区太少，无法完成读/写，则设置第 7 位(值=0x80)。这通常是由于在设置 DMA 字节计数时没有减去 1 造成的。如果您的驱动程序太慢，无法及时从 FIFO 端口获得字节，则设置位 4(值=0x10)。如果介质是写保护，则设置位 1(值=2)。其余的位用于各种类型的数据错误，指示坏的介质，或坏的驱动器。

**ST2**
ST2 寄存器提供了更多(无用的)关于读/写操作期间错误的细节。
这些位都表示各种类型的数据错误，要么是坏的介质，要么是坏的驱动器。

## 软盘控制器命令

软盘控制器共可以接受 15 条命令。每个命令均经历三个阶段：
- 命令阶段
- 执行阶段
- 结果阶段

命令阶段：是 CPU 向 FDC 发送命令字节和参数字节。每条命令的第一个字节总是命令字节（命令码）。 其后跟着0 ~ 8 字节的参数。
执行阶段：是 FDC 执行命令规定的操作。在执行阶段 CPU 是不加干预的，一般是通过 FDC 发出中断请求获知命令执行的结束。如果CPU 发出的 FDC 命令是传送数据，则 FDC 可以以中断方式或 DMA 方式进行。中断方式每次传送 1 字节。DMA 方式是在 DMA 控制器管理下，FDC 与内存进行数据的传输直至全部数据传送完。此时 DMA 控制器会将传输字节计数终止信号通知 FDC，最后由 FDC 发出中断请求信号告知 CPU 执行阶段结束。
结果阶段是由 CPU 读取 FDC 数据寄存器返回值，从而获得 FDC 命令执行的结果。返回结果数据的长度为 0 ~ 7 字节。对于没有返回结果数据的命令，则应向 FDC 发送检测中断状态命令获得操作的状态。

### 选项位

按位或 将这些位放到上面的读/写/格式化/验证命令中。
- MT：值=0x80，多磁道模式。在磁道结束时，控制器会自动从磁头 0 切换到磁头 1，这允许您用一个命令读/写两倍的数据；
- MF：值=0x40，MFM 磁编码方式，总是将其设置为读/写/格式化/验证操作，否则是 FM 编码方式；
- SK：值=0x20，跳过模式，忽略这一点，把它清除掉，除非你有一个非常好的理由不这样做；

### 马达延迟

建议马达启动时延迟 300ms（3.5 寸软盘）或 500ms（5.25 寸软盘），确保稳定。

### 重新初始化

BIOS 可能会使控制器保持默认状态。驱动轮询模式开启，FIFO 关闭，阈值 = 1，隐含寻道关闭，锁定关闭。
当操作系统初始化时:
1. 向控制器发送版本命令；
2. 验证结果字节是否为 0x90：
    1. 如果不是，则终止并不支持软盘子系统可能是一个好主意；
    2. 基于本文的几乎所有代码都可以工作，即使在最老的芯片组上也可以；
    3. 但是有一些命令不能工作；
3. 如果你不想在每个 Reset 过程之后发送另一个 Configure 命令，那么:
    1. 向控制器发送一个更好的 Configure 命令，建议是: 驱动轮询模式关闭，FIFO 开启，阈值=8，隐含寻道开启，预补偿 0；
    2. 发送一个 Lock 命令；
4. 执行 Controller Reset 操作；
5. 向每个驱动器发送一个校准命令；

### 控制器重置

对于任何软盘命令，第二个最常见的故障模式是软盘控制器永远锁定。此条件通过超时检测到，需要使用 Reset 来修复。在初始化期间还需要一次重置。希望它是您唯一需要做的。

1. 选择使用:
    1. DOR 中的第 2 位(值=4)：保存 DOR 的当前值/“原始”值，写入一个0到DOR，等待4微秒，然后将原始值(第2位总是设置)写回DOR；
    2. 或 DSR 中的第 7 位(值=0x80)：为 DSR 预计算一个良好的值(通常为 0) 与 0x80 进行按位或运算。将该值写入 DSR；
2. 等待产生的 IRQ6 (除非在 DOR 中关闭了 IRQ6)
3. 当(且仅当) 驱动轮询模式打开时，发送 4 个 Sense Interrupt 命令(必需的)；
4. 如果操作系统/驱动从来没有发送过一个 Lock 命令，那么可能需要发送一个新的 Configure 命令(FIFO 设置在重置中丢失了)；
5. 选择一个驱动器作为用于下一个要访问的驱动器；
注：重置清除所有的指定信息，因此下一个选择过程必须发送一个新的指定命令(使用某种标志来告诉驱动程序这样做)；
注：模拟器通常会在重置后将 Disk Change 标志设置为 `true`，但这不会发生在真正的硬件上，这是所有模拟器共同的错误。另一个 bug 是，如果磁盘轮询模式关闭，大多数模拟器不会触发 IRQ6；
注：重置不会改变驱动器轮询模式或隐含寻道设置；

### 驱动器选择

系统上的每个软盘驱动器可能是不同类型的，在访问不同类型的驱动器之间切换时，需要修复控制器中的 Specify 和 Datarate 设置。控制器不会记住每个驱动器的设置。它唯一记住的每个驱动器的数字是当前柱面。
1. 将正确的 Datarate 设置发送到 CCR。通常这是一个 0 (1.44MB 的软驱)；
2. 如果新选择的驱动器与以前选择的驱动器类型不同(或从 PIO 模式更改为 DMA 模式)，则发送一个新的 Specify 命令；
3. 正确设置 DOR 中的 **驱动器选择** 位(和其他标志)，包括可能打开驱动器的电机位(如果它将很快被访问)；

### 重新校正命令

该命令用来让磁头退回到 0 磁道，通常用于在软盘操作出错时对磁头重新校正定位。
其命令码是 0x07，参数是指定的驱动器号 0~3；
该命令无结果阶段，程序需要通过执行 **检测中断状态** 来获取该命令的执行结果。

### 磁头寻道命令

该命令让选中驱动器的磁头移动到指定磁道上。
- 第 1 个参数指定驱动器号和磁头号：
    - 位 0~1 是驱动器号
    - 位 2 是磁头号
    - 其它比特位无用
- 第 2 个参数指定磁道号

该命令也无结果阶段，程序需要通过执行 **检测中断状态** 来获取该命令的执行结果。

### 相对寻道

普通寻道命令允许从 0 ~ 255 之间选择柱面号的绝对值。也可以在所有情况下使用 相对寻道命令，特别是对于超过 255 个柱面的驱动器 (目前没有)。
若要使用相对查找，请将 MT 位设置为 1。要寻找更高的柱面编号，请设置 MFM 位，清除 MFM 以向后寻找更低的柱面编号。如果你寻道超过 255，会有很多额外的并发症。否则，该命令的行为与普通寻道相同。

### 设定命令

该命令用于设定软盘控制器内部的三个定时器初始值和选择传输方式，即：
- 驱动器马达步进速率 STR
- 磁头加载/卸载 (HLT/HUT) 时间
- 是否采用 DMA 方式来传输数据

参数：
- 设定命令=0x3
- 第一个参数字节= SRT << 4 | HUT
- 第二个参数字节= HLT << 1 | NDMA
- 没有结果字节
- 没有中断

通过设定命令发送给控制器的这些参数 是 为了优化驱动器性能和磁头寿命。这些值与系统上安装的软驱的确切型号、条件和年代有关。由驱动发送给控制器的值总是具有自适应性。也就是说，您的驱动程序理论上应该保持对于当前 SRT 设置下寻道命令失败的频率的统计信息。如果它们总是有效，并且您的驱动程序想要优化性能，那么它可以发送一个新的 Specify 命令，将 SRT 值减少 1。然后开始记录新的数据。HLT 的读/写操作也类似。随着驱动器年龄的增长和污垢的积累，驱动会通过看到更高的统计错误率来自动补偿，并增加 SRT 和 HLT 的值。

以这种方式保持统计数据只在有问题的驱动器经常使用时有效。现在，内部软盘驱动器几乎已经过时，它毫无价值。因此，目前的建议是使用非常安全的值，而不要考虑性能。

如果您查阅个别软盘驱动器的规格表，它们通常显示最坏情况的 “track to track seek time”= SRT，但其他两个不是。

- SRT(Step Rate Time) 步进速度时间，是控制器等待磁头组件在连续柱面之间移动的时间；单位 2ms

现代 3.5 英寸软盘驱动器需要 3ms 才能实现这一点。6 到 8 毫秒是一个非常安全的时间。要计算给定时间的 SRT 设置值，请使用 SRT_value = 16 -(毫秒* data_rate / 500000)。对于 1.44 MB 的软盘和 8ms 的延迟，这将给出“ SRT_value = 16 - (8 * 500000 / 500000) ” 或参数值 8。

- HLT(Head Load Time) 磁头加载时间，是控制器在激活磁头和实际执行读写之间应该等待的时间；单位 4ms

一个合理的值大约是 10ms。30ms 是一个非常安全的长度。要计算给定时间的 HLT 设置值，请使用 HLT_value = milliseconds * data_rate / 1000000。对于 1.44 MB 的软盘和 10ms 的延迟，这将得到 HLT_value = 10 * 500000 / 1000000 或 5。

- HUT(Head Unload Time) 磁头卸载时间，是控制器在停用头部前应等待的时间；单位 32ms

从给定的时间，使用 HUT_value =毫秒* data_rate / 8000000 来计算 HUT 设置的值。对于 1.44 MB 的软盘和 240 ms 的延迟，这将给出 HUT_value = 24 * 500000 / 8000000 或 15。然而，最聪明的做法似乎是将该值设置为 0(在任何模式下都是最大值)。

### 读/写命令

- 命令：
    - 读命令= MT | MFM | 0x6
    - 写命令= MT | MFM | 0x5
- 第一个参数字节 = (磁头 << 2) | 驱动器号(驱动器号必须与当前选择的驱动器匹配!)
- 第二个参数字节 = 柱面
- 第三个参数字节 = 磁头编号(是的，这是上面值的重复)
- 第四个参数字节 = 起始扇区号
- 第五个参数字节 = 2(所有软驱每个扇区使用 512 字节)
- 第六个参数字节= EOT(磁道结束，磁道上最后一个扇区号)
- 第七个参数字节= 0x1B (GAP1 默认大小)
- 第八个参数字节= 0xFF (当上面的扇区字节数为 0 时设置扇区字节数)

* 第一个结果字节= ST0 状态寄存器
* 第二个结果字节= ST1 状态寄存器
* 第三个结果字节= ST2 状态寄存器
* 第四个结果字节= 柱面号
* 第五个结果字节= 结束磁头号
* 第六个结果字节= 结束扇区号
* 第七个结果字节= 2

注：请记住这是 CHS 模式，所以扇区号从 1 开始；
注：如果您试图在没有等待 READY 设置的情况下读取结果字节，那么您可能总是会得到一个不正确的结果值 0。这也可能使您的驱动程序与 FDC 的输入/输出不同步。
注：这里没有扇区数量参数。相反，FDC 通过 DMA控制器 向 FDC 来发送 DMA 信号确定何时停止，或者在 PIO 模式下，通过 FDC 遭遇 FIFO 溢出或不足来确定何时停止。
注：软盘介质和电子驱动器是出了名的不可靠。任何读或写命令失败应该重试至少两次，除非它是写并且在 **写保护** 上失败。

### 配置命令

该命令初始化控制器特定的值：数据缓冲区 “阈值” 的值，隐含寻道有效, FIFO 禁用, 轮询启用。(和 写预补偿) 一个好的设置是：隐含寻道开启，FIFO 开启，驱动轮询模式关闭，阈值=8，预补偿 0。

如果您启用了隐含寻道，那么您不必发送查找命令(或者对查找命令发送 Sense Interrupt 命令)。

如果你发出 FIFO 禁用，那么它不能缓冲数据，你将得到一个 IRQ6 或 DMA 请求为每一个字节 (这需要快速服务，因为不然的话，传输中的下一个字节将自动导致上溢/下溢错误)；

驱动轮询模式只是为了向后软件兼容性而存在的一个麻烦。它让你在每次重置后都需要 Sense Interrupts。如果发送 Configure 命令，请始终关闭它。

一个大的阈值，如 15，将在中断之间等待 15 个字节。所以不会有很多中断，但是在 FIFO 溢出/下溢出并终止读写操作之前，你只剩下一个字节。thresh_val = threshold - 1

写预补偿是一个与驱动磁头有关的技术问题。写预补偿为 0 告诉控制器/驱动器使用制造商的默认值。除非有非常好的理由设置另一个值，否则请使用 0。

- 配置命令=0x13
- 第一个参数字节=0
- 第二个参数字节 =(隐含seek ENable << 6) | (fifo DISable << 5) | (驱动轮询模式禁用 << 4) | thresh_val (= threshold - 1)
- 第三个参数字节 = precomp_val = 0
- 没有结果字节
- 没有中断

### 版本命令

返回一个字节，取值为 0x90 时，表示软驱控制器为 82077AA。

- 版本命令=0x10
- 没有参数字节
- 没有中断
- 第一个结果字节=0x90

### 锁命令

在默认情况下，每一次控制器复位将禁用 FIFO，并将 FIFO 阈值设置为 1(thresh_val = 0)。如果你用 Configure 命令更改这些设置，并且不想在每次控制器复位后必须修复它们，那么你可以发送一个锁命令，锁位打开。您可以通过发送另一个 lock 命令并关闭锁位来释放锁。使用 MT 选项位作为锁位。

- 锁命令=0x94
- 或解锁命令=0x14
- 没有参数字节
- 没有中断
- 第一个结果字节=lock bit << 4

### 感知中断命令

该命令的主要功能是将 寻道 或 校准 命令中的任何错误代码返回给驱动程序。它还清除控制器中的一个内部位标志。在产生中断的下列三种情况下都需要它：

1. 在驱动器轮询模式打开后，执行控制器复位程序；
2. 在完成一个寻道命令(或相对寻道)之后；
3. 在重新校准命令完成之后；

只有在这些时候你才应该发送一个 Sense Interrupt，即使你在 DOR 中关闭了 IRQ 并且使用 PIO 轮询，你仍然应该发送它们。如果你在其他时间发送 Sense Interrupt 命令:命令将完成，返回0x80，然后锁住控制器，直到你进行复位。

- Sense Interrupt 命令=0x8；
- 没有参数字节；
- 没有中断；
- 第一个结果字节=ST0
- 第二个结果字节=控制器当前柱面

注：如果您试图在没有等待 RQM 设置的情况下读取结果字节，那么您可能总是会得到一个不正确的结果值 0。这也可能使您的驱动程序与 FDC 的输入/输出不同步。重置后，ST0 的正确值应为0xC0 |盘号(盘号=0 ~ 3)。校准/寻道后，ST0 的正确值应为 0x20 | 盘号 。

### 格式化操作

磁盘格式化包括将磁头定位到每个磁道，并创建用于数据存储的固定格式字段。在马达启动并达到稳定速度后，磁头返回零磁道，DMA 控制器提供磁道、磁头、扇区号等信息来建立标识字段。例如，磁头 1 格式化磁道 7 时，DMA 控制器需传输 36 字节的数据作为标识字段。完成一个磁道的格式化后，需要执行寻道操作移动到下一个磁道并重复格式化。因“格式化磁道”命令不含寻道操作，必须使用 SEEK 命令进行定位。


## 相关配置

```makefile
$(BUILD)/kernel/floppy.o \
```

```makefile
QEMU_DISK += -drive file=$(BUILD)/floppya.img,if=floppy,index=0,media=disk,format=raw # 软盘a
```

```makefile
$(BUILD)/floppya.img:

# 创建一个 1.44M 的软盘镜像
	yes | bximage -q -fd=1.44M -func=create -sectsize=512 -imgmode=flat $@

```


## 数据结构

```c
// 设备子类型
enum device_subtype_t
{
    //......
    DEV_FLOPPY,      // 软盘
    //......
};
```

```c
typedef struct floppy_t
{
    task_t *waiter; // 等待进程
    timer_t *timer; // 定时器
    lock_t lock;    // 锁

    char name[8];
    int type; // 软盘类型

    u8 dor; // dor registers

    u8 *buf; // DMA 地址 (其实是一样的)

    union
    {
        u8 tracks;    // 磁道数
        u8 cylinders; // 柱面数
    };
    u8 heads;   // 磁头数
    u8 sectors; // 每磁道扇区数
    u8 gap3;    // GAP3 长度

    u8 drive;   // 磁盘序号
    u8 st0;     //
    u8 track;   // 当前磁道
    u8 motor;   // 马达状态
    u8 changed; // 磁盘发生改变

    union
    {
        u8 st[RESULT_NR];
        fdresult_t result;
    };

} floppy_t;
```


## 相关函数

```c
// 更新定时器超时
void timer_update(timer_t *timer, u32 expire_ms)
{
    list_remove(&timer->node); // 移除列表
    timer->expires = jiffies + expire_ms / jiffy;
    list_insert_sort(&timer_list, &timer->node, element_node_offset(timer_t, node, expires));
}

u32 timer_expires()
{
    if (list_empty(&timer_list))
    {
        return EOF;
    }
    timer_t *timer = element_entry(timer_t, node, timer_list.head.next);
    return timer->expires;
}

// 得到超时时间片
int timer_expire_jiffies(u32 expire_ms)
{
    return jiffies + expire_ms / jiffy;
}

// 判断是否已经超时
bool timer_is_expires(u32 expires)
{
    return jiffies > expires;
}
```

```c
// 初始化
void floppy_init()
{
    LOGK("floppy disk init...\n");

    floppy_t *fd = &floppy;
    fd->type = fd_type();
    if (!fd->type) // 主驱动器不存在
    {
        LOGK("floppy drive not exists...\n");
        return;
    }

    strcpy(fd->name, "fda");
    if (fd->type != FDT_144M)
    {
        LOGK("floppy %s type %d not supported!!!\n", fd->name, fd->type);
        return;
    }

    LOGK("floppy %s 1.44M init...\n", fd->name);

    // 设置中断处理函数，以及中断屏蔽字
    set_interrupt_handler(IRQ_FLOPPY, fd_handler);
    set_interrupt_mask(IRQ_FLOPPY, true);

    lock_init(&fd->lock);

    fd->waiter = NULL;

    fd->dor = (DOR_IRQ | DOR_NORMAL);

    fd->buf = (u8 *)DMA_BUF_ADDR;

    fd->tracks = 80;
    fd->heads = 2;
    fd->sectors = 18;
    fd->gap3 = 0x1B;

    fd->drive = 0;
    fd->track = 0xFF;

    if (fd_setup(fd) < EOK)
        return;

    device_install(
        DEV_BLOCK, DEV_FLOPPY, fd, fd->name, 0,
        fd_ioctl, fd_read, fd_write);
}

// 用于处理软盘的数据传输操作，包括读和写
static err_t fd_transfer(floppy_t *fd, bool mode, void *buf, u8 count, idx_t lba)
{
    u8 track, head, sector;

    // 转换 lba 到 chs cylinder head sector
    lba2chs(fd, lba, &track, &head, &sector);

    // 当前磁道剩余扇区数
    u8 remaining = ((fd->sectors + 1 - sector) + fd->sectors * (fd->heads - head - 1));

    // 这个地方确实有问题，可能存在读取内容较少，外层做了兼容；
    if (remaining < count)
        count = remaining;

    if (mode == FD_WRITE)
        memcpy(fd->buf, buf, count * SECTOR_SIZE);

    // Perform seek if necessary
    fd_seek(fd, track, head);

    // Program data rate (500K/s)
    outb(FDC_CCR, 0);

    // 设置 DMA
    isa_dma_mask(2, false);
    isa_dma_reset(2);

    if (mode == FD_READ)
        isa_dma_mode(2, DMA_MODE_SINGLE | DMA_MODE_READ);
    else
        isa_dma_mode(2, DMA_MODE_SINGLE | DMA_MODE_WRITE);

    // Setup DMA transfer
    isa_dma_addr(2, fd->buf);
    isa_dma_size(2, (u32)count * SECTOR_SIZE);
    isa_dma_mask(2, true);

    // 执行读写请求
    if (mode == FD_READ)
        fd_outb(CMD_READ);
    else
        fd_outb(CMD_WRITE);

    fd_outb((u8)((head << 2) | fd->drive));
    fd_outb(track);
    fd_outb(head);
    fd_outb(sector);
    fd_outb(0x02); // 512 bytes/sector
    fd_outb(fd->sectors);
    fd_outb(fd->gap3);
    fd_outb(0xFF); // DTL = unused

    assert(fd_wait(fd) == EOK); // 等待中断

    fd_result(fd, false);

    if ((fd->result.st0 & 0xC0) == 0)
    {
        // Successful transfer
        if (mode == FD_READ)
            memcpy(buf, fd->buf, count * SECTOR_SIZE);
        return EOK;
    }
    else
    {
        LOGK("fd: xfer error, st0 %02X st1 %02X st2 %02X THS=%d/%d/%d\n",
             fd->result.st0, fd->result.st1, fd->result.st2,
             fd->result.track, fd->result.head, fd->result.sector);
        return -EIO;
    }
}

static err_t fd_write(floppy_t *fd, void *buf, u8 count, idx_t lba)
{
    assert(count + lba < (u32)fd->tracks * fd->heads * fd->sectors);

    lock_acquire(&fd->lock);
    fd_motor_on(fd);

    int ret = fd_transfer(fd, FD_WRITE, buf, count, lba);

    fd_motor_off(fd);
    lock_release(&fd->lock);
    return ret;
}
```


## 参考文献

- <https://wiki.osdev.org/Floppy>
- <http://www.brokenthorn.com/Resources/OSDev20.html>
- <https://www.qemu.org/docs/master/system/qemu-manpage.html>
- <https://wiki.osdev.org/CMOS#Register_0x10>
- [赵炯 / Linux内核完全注释 / 机械工业出版社 / 2005](https://book.douban.com/subject/1231236/)


---

# 19.PCI 总线

PCI Peripheral Component Interconnect 总线用于建立高性能低成本的局部总线。
![](./images/PCI_System_Block.jpg)


## 配置空间

PCI 规范通过独立的配置地址空间，为每个 PCI 设备（除主机总线桥外）提供软件驱动的初始化和配置。这些设备需提供 256 字节的配置寄存器。
配置读写周期用于访问设备的配置空间。期间，通过目标设备的 IDSEL 信号确定目标，IDSEL 充当片选信号。地址阶段，处理器通过地址线 AD [7..2] 和字节启用行访问配置空间内的 64 个 32 位寄存器。
PCI 设备采用小端存储方式，多字节字段的最低有效字节位于较低地址。大端处理器需要正确交换字节以访问 PCI 设备，包括配置空间。


## 配置机制

使用了两个 32 位的 I/O位置，第一个位置 (`0xCF8`) 被称为 `PCI_CONF_ADDR`，第二个位置 (`0xCFC`) 被称为 `PCI_CONF_DATA`。 `PCI_CONF_ADDR` 指定需要访问的配置地址，而对 `PCI_CONF_DATA` 的访问将实际生成配置访问，并将数据传输到 `PCI_CONF_DATA` 寄存器或从 `PCI_CONF_DATA` 寄存器得到数据。
`PCI_CONF_ADDR` 是一个 32 位寄存器，其格式如表。第 31 位是一个启用标志，用于确定何时应该将对 `PCI_CONF_DATA` 的访问转换为配置周期。第 23 位到第 16 位允许组态软件选择系统中特定的 PCI 总线。第 15 到 11 位选择 PCI 总线上的特定设备。第 10 位到第 8 位用于选择设备中的特定功能(如果该设备支持多种功能)。
最低有效字节选择通过此方法可用的 256 字节配置空间中的偏移量。因为所有的读和写操作都必须是 32 位对齐的， `PCI_CONF_ADDR` 的最低两位必须始终为零，剩下的 6 位允许您选择 64 个 32 位字中的每一个。如不需所有的 32 位，将在软件中通过对齐地址来执行非对齐访问，然后屏蔽和移位结果。
|   位    |    描述    |
| :-----: | :--------: |
|  0 ~ 7  | 寄存器偏移 |
| 8 ~ 10  |   功能号   |
| 11 ~ 15 |   设备号   |
| 16 ~ 23 |   总线号   |
| 24 ~ 30 |    保留    |
|   31    |   有效位   |

其数据结构为：
```c
typedef struct pci_addr_t
{
    u8 RESERVED : 2; // 最低位
    u8 offset : 6;   // 偏移
    u8 function : 3; // 功能号
    u8 device : 5;   // 设备号
    u8 bus;          // 总线号
    u8 RESERVED : 7; // 保留
    u8 enable : 1;   // 地址有效
} _packed pci_addr_t;
```

相关定义为：
```c
#define PCI_ADDR(bus, dev, func, addr) ( \
    (u32)(0x80000000) |                  \
    ((bus & 0xff) << 16) |               \
    ((dev & 0x1f) << 11) |               \
    ((func & 0x7) << 8) |                \
    addr)
```


## 检测配置空间访问机制

一般有四种情况:
- 计算机不支持PCI
- 计算机支持机制2
- 计算机支持机制1，但不支持内存映射访问机制
- 计算机同时支持 机制1 和 内存映射访问机制

在BIOS系统中，使用 int 0x1A, AX=0xB101 可以判断系统是支持机制1还是机制2。如果该函数不存在，则无法确认计算机是否支持PCI。即使支持机制1，也无法确定是否支持内存映射访问。
在UEFI系统中，通常可以安全地假设不支持机制2。通过检查“PCI总线支持”协议的存在性，可以测试计算机是否支持PCI，但无法简单地确定是否支持机制1。
在BIOS和UEFI系统中，可以通过检查ACPI表来确定是否支持内存映射访问。
如果这些方法都无法确定，唯一的选择是手动探测。

## PCI 设备结构

PCI 规范定义了 256 字节配置空间寄存器的组织，并为该空间引入了一个特定的模板。图 2 和 3 显示了 256 字节配置空间的布局。所有 PCI 兼容设备必须支持 供应商ID、设备ID、命令和状态、修订ID、类代码 和 报头类型 字段。其他寄存器的实现是可选的，这取决于设备的功能。
![](./images/PCI_Configuration_Space.jpg)

- Device ID(设备 ID)：
    标识特定的设备，有效的 ID 由供应商分配
- Vendor ID(供应商 ID)：
    标识设备的制造商。有效的 ID 是由 PCI-SIG [^companies] 分配的，以确保唯一性，`0xFFFF` 是一个无效的值，将在读取不存在设备的配置空间寄存器时返回
- 状态寄存器
    用于记录 PCI 总线相关事件的状态信息（见下文）
- 命令寄存器
    提供对设备生成和响应 PCI 周期的能力的控制。所有设备都支持的唯一功能是，当向该寄存器写入 0 时，除配置空间访问外，都断开设备与 PCI 总线的所有访问连接（见下文）
- Class Code (类型码)：
    一种只读寄存器，它指定设备执行的功能类型
- Subclass (子类型)：
    用于指定设备执行的特定功能
- Prog IF (Programming Interface Byte 编程接口字节)
    一种只读寄存器，它指定设备具有的寄存器级编程接口(如果有的话)
- Revision ID (修订 ID)：
    为特定设备指定修订标识符。有效的id由供应商分配。
- BIST (built-in self test 内置自检)
    表示该状态并允许控制设备 BIST
- Header Type (头类型)
    标识从字节 0x10 开始的头的其余部分的布局，还指定设备是否具有多个功能。其中 0x0 指通用设备，0x1 指 PCI - PCI 桥，0x2 指 CardBus 桥
    如果设置了该寄存器的第 7 位，则设备具有多种功能，否则为单一功能设备
- Latency Timer (延迟计时器)
    以 PCI 总线时钟为单位指定延迟计时器
- Cache Line Size (缓存线大小)
    指定系统缓存行大小，以 32 位为单位。设备可以限制其支持的缓存先大小的数量，如果将不支持的值写入该字段，设备的行为将像写入值为 0 一样
- CardBus CIS 指针
    指向卡信息结构，由 CardBus 和 PCI 之间共享硅的设备使用
- 中断线
    指定设备的中断引脚连接到系统中断控制器的哪个输入，并且由任何使用中断引脚的设备实现。对于 x86 架构，这个寄存器对应于 PIC IRQ 编号0-15(而不是I/O APIC IRQ编号)，0xFF 的值定义没有连接
- 中断引脚
    指定设备使用的中断引脚。其中：
    - 0x1 是 INTA#
    - 0x2 是 INTB#
    - 0x3 是 INTC#
    - 0x4 是 INTD#
    - 0x0 表示设备没有使用中断引脚
- 最大延迟时间
    只读寄存器，指定设备需要访问 PCI 总线的频率(以 1/4 微秒为单位)
- Min Grant
    只读寄存器，指定设备需要的突发周期长度，单位为 1/4 微秒(假设时钟频率为 33 MHz)
- 功能指针
    指向一个由设备实现的新功能链表的指针(即该函数配置空间的偏移量)。如果状态寄存器(能力列表位)的第 4 位设置为 1，则使用。底部的两位是保留的，并且应该在指针被用来访问配置空间之前被屏蔽。


## 命令寄存器

![](./images/PCI_Command_Register.jpg)

| 位      | 英文                               | 描述             |
| ------- | ---------------------------------- | ---------------- |
| 0       | I/O Space                          | I/O 空间         |
| 1       | Memory Space                       | 内存空间         |
| **2**   | **Bus Master**                         | **总线主控**     |
| 3       | Special Cycles                     | 特殊周期         |
| 4       | Memory Write and Invalidate Enable ||
| 5       | VGA Palette Snoop                  | VGA 调色板窥探   |
| 6       | Parity Error Response              | 奇偶校验错误响应 |
| 7       | Reserved                           ||
| 8       | SERR# Enable                       | SERR# 有效       |
| 9       | Fast Back-to-Back Enable           ||
| 10      | Interrupt Disable                  | 中断无效         |
| 11 ~ 15 | Reserved                           | 保留             |

- I/O Space  I/O空间
    如果设置为 1，设备可以响应 I/O 空间访问;否则，设备响应被禁用。
- Memory Space 内存空间
    如果设置为 1，设备可以响应内存空间访问;否则，设备响应被禁用。
- Bus Master 总线主控
    如果设置为 1，设备可以表现为总线主控;否则设备无法生成 PCI 访问。
- Special Cycles 特殊周期
    如果设置为 1，设备可以监控特殊周期操作;否则，设备将忽略它们。
- Memory Write and Invalidate Enable
    如果设置为 1，设备可以生成 Memory Write and Invalidate 命令;否则，必须使用 Memory Write 命令
- VGA Palette Snoop VGA 调色板窥探
    如果设置为 1，设备不响应调色板寄存器写，并将窥探数据;否则，设备将像对待所有其他访问一样对待调色板写访问。
- Parity Error Response 奇偶校验错误响应
    如果设置为 1，当检测到奇偶校验错误时，设备将采取其正常的行动; 否则，当检测到错误时，设备将设置状态寄存器的第 15 位(检测奇偶校验错误状态位)，但不会断言 PERR#(奇偶校验错误) 引脚，并将继续正常操作。
- 第 7 位：保留
    在 PCI 本地总线规范的 3.0 修订版中，该位被硬连接到 0。在该规范的早期版本中，该位由设备使用，可能已经硬连接到 0、1 或实现为读/写位
- SERR# Enable SERR# 有效
    如果设置为 1 SERR# 驱动有效;否则，驱动被禁用
- Fast Back-Back Enable
    如果设置为 1，表示允许设备生成快速的背靠背事务; 否则，快速背靠背事务只允许用于同一代理。
- Interrupt Disable 中断禁用
    如果设置为 1，则禁用设备的 INTX# 信号，否则，将启用信号


## 头类型寄存器

| 位    | 描述       |
| ----- | ---------- |
| 0 ~ 6 | 头类型     |
| 7     | 是否多功能 |


## BIST 寄存器

| 位    | 描述      |
| ----- | --------- |
| 0 ~ 3 | 完成码    |
| 4 ~ 5 | 保留      |
| 6     | 开始 BIST |
| 7     | BIST 能力 |

- BIST 能力：设备支持 BIST 时为 1
- 开始 BIST： 设备 BIST 开始后为 1，当 BIST 完成时被清除，若 BIST 开始 2 秒后 BIST 还未结束，表示设备故障；
- 完成码：若 BIST 执行成功后，应该为 0


## 基址寄存器 Base Address Registers (BAR)

基址寄存器(BAR) 可以用来保存设备使用的内存地址，或端口地址的偏移量。通常，内存地址 BAR 需要位于物理 RAM 中，而 I/O 空间 BAR 可以驻留在任何内存地址(甚至超出物理内存)。要区分它们，可以检查最低位的值。下面的表格描述了两种类型的 BAR:

内存空间 BAR 布局
| 位     | 英文                         | 描述           |
| ------ | ---------------------------- | -------------- |
| 0      | Always 0                     | 常为0          |
| 1 ~ 2  | Type                         | 类型           |
| 3      | Prefetchable                 |
| 4 ~ 31 | 16 Byte Aligned Base Address | 16字节对齐基址 |

I/O 空间 BAR 布局
| 位     | 英文                        | 描述          |
| ------ | --------------------------- | ------------- |
| 0      | Always 1                    | 常为 1        |
| 1      | Reserved                    | 保留          |
| 2 ~ 31 | 4-Byte Aligned Base Address | 4字节对齐基址 |

Memory Space BAR Layout 的 Type 字段指定基本寄存器的大小，以及它在内存中的映射位置：
- 0x0，那么基本寄存器是 32 位宽的，可以映射到 32 位内存空间中的任何位置。
- 0x2 的值意味着基址寄存器是 64 位宽的，可以映射到 64 位内存空间中的任何位置(64 位基址寄存器消耗 2 个可用的基址寄存器)
- 0x1 的值在 PCI 本地总线规范3.0版本中保留。在早期版本中，它用于支持 1MB 以下的内存空间(可以映射到 16 位内存空间中的任何位置的 16 位宽基本寄存器)

当基址寄存器被标记为可预取时，这意味着该区域没有读取的副作用(从该内存范围读取不会改变任何状态)，并且允许 CPU 从该内存区域缓存负载并突然读取它(通常是缓存行大小)。硬件还允许将重复存储合并到同一个地址，并将其合并到一个最新值的存储中。如果您正在使用分页并希望获得最大的性能，那么应该将可预取的 MMIO 区域映射为WT(透写) 而不是 UC (不可缓存)。在 x86 上，帧缓冲区是个例外，它们应该总是被映射为 WC(写合并)


## BAR 的地址和大小

当想要检索 BAR 的实际基址时，请确保屏蔽较低的位。
- 对于 16 位内存空间 BAR，计算(BAR[x] & 0xFFF0)
- 对于 32 位内存空间 BAR，计算(BAR[x] & 0xFFFFFFF0)
- 对于 64 位内存空间 BAR，计算((BAR[x] & 0xFFFFFFF0) + ((BAR[x + 1] & 0xFFFFFFFF) << 32))
- 对于 I/O 空间 BAR，计算(BAR[x] & 0xFFFFFFFC)。

要确定 PCI 设备所需的地址空间，首先保存 BAR（基址寄存器）的原始值，然后将寄存器写入全 1，再读取回来。通过屏蔽信息位、按位取反，并加1即可得出内存大小。之后应恢复BAR的原始值。BAR 寄存器是自然对齐的，只能修改高位。例如，一个设备需要 16MB 时，其 BAR0 会填充 0xFF000000，解码后为 0x1000000，只能修改高 8 位。
PCI 的内存区域都是2的幂次方，如 1K、2K、4K 等。写入基址的低位会自动置为 0，因此基址会对齐到如 0x1000 或 0xabcde000 这样的地址，而不会是 0x1234。向 BAR 写入 0xffffffff 时，低位会被忽略，读出的值按位取反后加 1 即可得到内存大小或限制。


## 类型码

Class Code、Subclass 和 Prog IF 寄存器分别用来标识设备的类型、设备的功能和设备的寄存器级编程接口。

| 字节 | 说明       |
| ---- | ---------- |
| 0    | Prog IF    |
| 1    | Subclass   |
| 2    | Class Code |


## 处理中断

如果你用的是旧的 PIC，真的很简单。您有头部的 Interrupt Line 字段，它是可读可写的(您可以更改它的值)，它表示当需要注意时哪个中断将触发 PCI 设备


## 多功能设备

多功能设备与普通 PCI 设备的行为方式相同。检测多功能设备最简单的方法是头部类型字段的第 7 位。如果设置了(value = 0x80)，则该设备是多功能的，否则就不是。在确定头类型时，请确保屏蔽此位。要检测功能的数量，您需要扫描每个功能的 PCI 配置空间，未使用的功能的供应商是 `0xFFFF`。不同功能的设备id和类码不同。功能不一定是按顺序排列的，可以只使用功能 0x0、0x1 和 0x7。


## 部分设备

- 0x8086：Intel
    - 0x1237：440FX - 82441FX PMC
    - 0x7000：82371SB PIIX3 ISA
    - 0x100e：82540EM Gigabit Ethernet Controller
- 0x1234：Qemu
    - 0x1111: QEMU Virtual Video Controller


## 相关函数

```c
// 检测 PCI 设备
static void pci_check_device(u8 bus, u8 dev)
{
    u32 value = 0;

    for (u8 func = 0; func < 8; func++)
    {
        value = pci_inl(bus, dev, func, PCI_CONF_VENDOR);
        u16 vendorid = value & 0xFFFF;
        if (vendorid == 0 || vendorid == 0xFFFF)
            return;

        pci_device_t *device = (pci_device_t *)kmalloc(sizeof(pci_device_t));
        list_push(&pci_device_list, &device->node);
        device->bus = bus;
        device->dev = dev;
        device->func = func;

        device->vendorid = vendorid;
        device->deviceid = value >> 16;

        value = pci_inl(bus, dev, func, PCI_CONF_COMMAND);
        pci_command_t *cmd = (pci_command_t *)&value;
        pci_status_t *status = (pci_status_t *)(&value + 2);

        value = pci_inl(bus, dev, func, PCI_CONF_REVISION);
        device->classcode = value >> 8;
        device->revision = value & 0xFF;

        LOGK("PCI %02x:%02x.%x %4x:%4x %s\n",
             device->bus, device->dev, device->func,
             device->vendorid, device->deviceid,
             pci_classname(device->classcode));
    }
}

// 根据供应商/设备号查找设备
pci_device_t *pci_find_device(u16 vendorid, u16 deviceid)
{
    list_t *list = &pci_device_list;
    for (list_node_t *node = list->head.next; node != &list->tail; node = node->next)
    {
        pci_device_t *device = element_entry(pci_device_t, node, node);
        if (device->vendorid == vendorid && device->deviceid == deviceid)
            return device;
    }
    return NULL;
}

// 根据设备类型查找设备
pci_device_t *pci_find_device_by_class(u32 classcode)
{
    list_t *list = &pci_device_list;

    for (list_node_t *node = list->head.next; node != &list->tail; node = node->next)
    {
        pci_device_t *device = element_entry(pci_device_t, node, node);
        if (device->classcode == classcode || (device->classcode & PCI_SUBCLASS_MASK) == classcode)
            return device;
    }
    return NULL;
}

// 获取设备的中断 IRQ
u8 pci_interrupt(pci_device_t *device)
{
    u32 data = pci_inl(device->bus, device->dev, device->func, PCI_CONF_INTERRUPT);
    return data & 0xFF;
}

// 启用总线主控功能以进行 DMA
void pci_enable_busmastering(pci_device_t *device)
{
    u32 data = pci_inl(device->bus, device->dev, device->func, PCI_CONF_COMMAND);
    data |= PCI_COMMAND_MASTER;
    pci_outl(device->bus, device->dev, device->func, PCI_CONF_COMMAND, data);
}

// 执行 PCI 总线设备枚举
static void pci_enum_device()
{
    for (int bus = 0; bus < 256; bus++)
    {
        for (int dev = 0; dev < 32; dev++)
        {
            pci_check_device(bus, dev);
        }
    }
}

// 初始化 PCI 设备系统
void pci_init()
{
    list_init(&pci_device_list);
    pci_enum_device();
}
```


## 参考文献

- <https://lekensteyn.nl/files/docs/PCI_SPEV_V3_0.pdf>
- <https://wiki.osdev.org/PCI>
- <https://pcisig.com/specifications/conventional/>
- <https://pcisig.com/membership/member-companies>


---


# 20.磁盘驱动优化

## 磁盘类型检测

来自 ATA/ATAPI 规范的草案副本(T13 1410D rev 3b, 365页)，对 qemu 有效。

要检测 ATA 磁盘是非包设备还是包设备，可以使用存储在 `sector count` 和 `LBA Low,Mid,High` 寄存器中的签名 (对于 ATA 控制器，寄存器 0x1F2-0x1F5)。

如果这些寄存器是 0x01, 0x01, 0x00, 0x00，那么连接的设备是非包设备，`IDENTIFY DEVICE(0xEC)` 功能应该有效。如果它们是 0x01, 0x01, 0x14, 0xEB，那么该设备是一个包设备，并且应该使用 `IDENTIFY PACKET DEVICE(0xA1)` 来检测设备。

当设备上电、复位或接收 `EXECUTE DEVICE DIAGNOSTIC` 命令时，该签名被设置/重置 (对于数据包设备，`IDENTIFY DEVICE` 也会重置签名)。有些关键的寄存器会被设为初始值，可根据初始值来判断是什么设备。

## 磁盘错误处理

将磁盘错误，逐步向上传递；

## 相关定义

### IDE 寄存器偏移
- CHS 扇区位置：#define IDE_CHS_SECTOR 0x0003
- CHS 柱面低字节：#define IDE_CHS_CYL 0x0004 
- CHS 柱面高字节：#define IDE_CHS_CYH 0x0005

### IDE 命令
- 读命令：#define IDE_CMD_READ 0x20  
- 写命令：#define IDE_CMD_WRITE 0x30  
- 识别命令：#define IDE_CMD_IDENTIFY 0xEC
- 诊断命令：#define IDE_CMD_DIAGNOSTIC 0x90

- CHS 模式 MASK：#define IDE_SEL_MASK 0b10110000

- IDE 接口的未知状态或类型：#define IDE_INTERFACE_UNKNOWN 0
- IDE 的 ATA 硬盘：#define IDE_INTERFACE_ATA 1 
- IDE接口连接的设备是 ATAPI 设备：#define IDE_INTERFACE_ATAPI 2

### 0x1F6

- 6：0 CHS, 1 LBA
    应置为0


## 相关函数

```c
// 设备探测
static err_t ide_probe_device(ide_disk_t *disk)
{
    outb(disk->ctrl->iobase + IDE_HDDEVSEL, disk->selector & IDE_SEL_MASK);
    ide_delay();

    outb(disk->ctrl->iobase + IDE_SECTOR, 0x55);
    outb(disk->ctrl->iobase + IDE_CHS_SECTOR, 0xAA);

    outb(disk->ctrl->iobase + IDE_SECTOR, 0xAA);
    outb(disk->ctrl->iobase + IDE_CHS_SECTOR, 0x55);

    outb(disk->ctrl->iobase + IDE_SECTOR, 0x55);
    outb(disk->ctrl->iobase + IDE_CHS_SECTOR, 0xAA);

    u8 sector_count = inb(disk->ctrl->iobase + IDE_SECTOR);
    u8 sector_index = inb(disk->ctrl->iobase + IDE_CHS_SECTOR);

    if (sector_count == 0x55 && sector_index == 0xAA)
        return EOK;
    return -EIO;
}

// 检测设备类型
static int ide_interface_type(ide_disk_t *disk)
{
    outb(disk->ctrl->iobase + IDE_COMMAND, IDE_CMD_DIAGNOSTIC);
    if (ide_busy_wait(disk->ctrl, IDE_SR_NULL, IDE_TIMEOUT) < EOK)
        return IDE_INTERFACE_UNKNOWN;

    outb(disk->ctrl->iobase + IDE_HDDEVSEL, disk->selector & IDE_SEL_MASK);
    ide_delay();

    u8 sector_count = inb(disk->ctrl->iobase + IDE_SECTOR);
    u8 sector_index = inb(disk->ctrl->iobase + IDE_LBA_LOW);
    if (sector_count != 1 || sector_index != 1)
        return IDE_INTERFACE_UNKNOWN;

    u8 cylinder_low = inb(disk->ctrl->iobase + IDE_CHS_CYL);
    u8 cylinder_high = inb(disk->ctrl->iobase + IDE_CHS_CYH);
    u8 state = inb(disk->ctrl->iobase + IDE_STATUS);

    if (cylinder_low == 0x14 && cylinder_high == 0xeb)
        return IDE_INTERFACE_ATAPI;

    if (cylinder_low == 0 && cylinder_high == 0 && state != 0)
        return IDE_INTERFACE_ATA;

    return IDE_INTERFACE_UNKNOWN;
}
```
```c
static err_t ide_busy_wait(ide_ctrl_t *ctrl, u8 mask, int timeout_ms)
{
    int expiration = timer_expire_jiffies(timeout_ms);
    while (true)
    {
        // 超时检查
        if (timeout_ms > 0 && timer_is_expires(expiration))
        {
            return -ETIME;
        }

        // 从备用状态寄存器中读取状态
        u8 status = inb(ctrl->iobase + IDE_ALT_STATUS);
        if (status & IDE_SR_ERR) // 检测到错误
        {
            ide_error(ctrl);
            ide_reset_controller(ctrl);
            return -EIO;
        }
        if (status & IDE_SR_BSY) // 控制器忙
        {
            ide_delay();
            continue;
        }
        if ((status & mask) == mask) // 期望状态完成
            return EOK;
    }
}

// 重置硬盘控制器
static err_t ide_reset_controller(ide_ctrl_t *ctrl)
{
    outb(ctrl->iobase + IDE_CONTROL, IDE_CTRL_SRST);
    ide_delay();
    outb(ctrl->iobase + IDE_CONTROL, ctrl->control);
    return ide_busy_wait(ctrl, IDE_SR_NULL, IDE_TIMEOUT);
}
```


## 参考文献

- <https://github.com/ringgaard/sanos>
- <https://wiki.osdev.org/ATAPI>


---


# 21.IDE 硬盘 UDMA

## 目前的读写机制

### IDE 硬盘机制

读写时，用户缓冲区与内核高速缓存之间进行数据拷贝；如果缓存未命中，则使用 ide_pio_read/write 访问磁盘，效率较低。

### ISA DMA 软盘机制

与 IDE 类似，但由于 dma_buf 限制，存在多次内存拷贝，效率更低。

## ISA DMA

ISA DMA 速度较慢，限于 4MB/s，而 ATA 磁盘使用的 PCI 总线主控 DMA 更快，支持 UDMA。

## UDMA

UDMA (Ultra Direct Memory Access)：是一种高级 DMA 模式，区别在于数据传输的方式和速度。OS 仅需在启动时初始化 DMA 模式。
CRC 错误处理：UDMA 特有的错误处理方式，当数据传输损坏时，需重试传输。

### 验证 CRC 错误

读取 PCI Configuration Space uint16_t 在偏移量6(设备状态)获得错误码。


## PRD 表

### 设置 PRD 表

PRD 表：存储物理区域描述符，用于 DMA 传输。每个 uint64_t 条目定义了内存地址和传输大小。
内存对齐要求：PRD 表必须 uint32_t 对齐，且不能跨越 64K 边界。


## 总线主控寄存器

总线主控寄存器的 “地址” 存储在磁盘控制器的 PCI 配置空间的 BAR4 中。总线主寄存器通常是 16 个顺序 IO 端口的集合。它也可以是一个 16 字节的内存映射空间。
格式如下：
| 偏移      | 通道 | 功能      |
| --------- | ---- | --------- |
| 0x0       | 主   | 命令      |
| 0x2       | 主   | 状态      |
| 0x4 ~ 0x7 | 主   | PRDT 地址 |
| 0x8       | 从   | 命令      |
| 0xA       | 从   | 状态      |
| 0xC ~ 0xF | 从   | PRDT 地址 |

### 命令字节

用于控制 DMA 的开始、停止和读写操作。

### 状态字节

提供 DMA 操作状态，处理 IRQ 后需读取并刷新缓存。


## ATA/ATAPI Commands

驱动程序需向磁盘发送特定命令以开始 DMA 传输，并根据 PRD 表管理数据传输。
| 命令字节 | 功能                   |
| -------- | ---------------------- |
| 0xC8     | Read DMA (28 bit LBA)  |
| 0x25     | Read DMA (48 bit LBA)  |
| 0xCA     | Write DMA (28 bit LBA) |
| 0x35     | Write DMA (48 bit LBA) |

## 错误处理

在传输之后，如果总线主状态字节的 ERR 位(位1，值= 2)被设置，那么通过向该端口写入一个 2 来清除它。然后可以读取总线的 LBA IO 端口(0x1F3 到 0x1F6)，以找出哪个扇区失败了。


## 发送命令的标准顺序

1. 在系统内存中准备一个 PRDT。
2. 发送物理 PRDT 地址到总线主 PRDT 寄存器。
3. 通过设置总线主命令寄存器的读/写位来设置数据传输的方向。
4. 清除总线主状态寄存器中的错误和中断位。
5. 选择驱动器（硬盘）。
6. 将 LBA 和扇区计数发送到各自的端口。
7. 向 ATA 控制器发送 DMA 传输命令。
8. 在总线主命令寄存器上设置启动/停止位。
9. 当中断到达时(传输完成后)，通过重置启动/停止位来响应。
10. 读取控制器和驱动器状态，以确定传输是否成功完成。


## 相关定义
- 编程 IO：#define IDE_TYPE_PIO 0
- Ultra DMA：#define IDE_TYPE_UDMA 1 

- 存储控制器的 IDE 设备：#define PCI_CLASS_STORAGE_IDE 0x010100
    "IDE interface"

## 数据结构

```c
// IDE 控制器
typedef struct ide_ctrl_t
{
    //......
    int iotype;                    // 设备 IO 类型
    u16 iobase;                    // IO 寄存器基址
    u16 bmbase;                    // PCI 总线主控寄存器基地址
    //......
    ide_prd_t prd;                 // Physical Region Descriptor 与磁盘进行交互
} ide_ctrl_t;
```
```c
typedef struct task_t
{
    //......
    struct timer_t *timer;              // 超时定时器
    //......
} task_t;
```


## 相关函数

```c
// 获取虚拟地址 vaddr 对应的物理地址
u32 get_paddr(u32 vaddr)
{
    page_entry_t *pde = get_pde();
    page_entry_t *entry = &pde[DIDX(vaddr)];
    if (!entry->present)
        return 0;

    entry = get_entry(vaddr, false);
    if (!entry->present)
        return 0;

    return PAGE(entry->index) | (vaddr & 0xfff);
}

// 获取指定类型的 Base Address Register
err_t pci_find_bar(pci_device_t *device, pci_bar_t *bar, int type)
{
    for (size_t idx = 0; idx < PCI_BAR_NR; idx++)
    {
        u8 addr = PCI_CONF_BASE_ADDR0 + (idx * 4);
        u32 original_value = pci_inl(device->bus, device->dev, device->func, addr);
        pci_outl(device->bus, device->dev, device->func, addr, 0xFFFFFFFF);
        u32 updated_value = pci_inl(device->bus, device->dev, device->func, addr);
        pci_outl(device->bus, device->dev, device->func, addr, original_value);

        if (original_value == 0)
            continue;

        if (updated_value == 0 || updated_value == 0xFFFFFFFF)
            continue;

        if (original_value == 0xFFFFFFFF)
            original_value = 0;

        if ((original_value & 1) && type == PCI_BAR_TYPE_IO)
        {
            bar->iobase = original_value & PCI_BAR_IO_MASK;
            bar->size = pci_size(updated_value, PCI_BAR_IO_MASK);
            return EOK;
        }
        if (!(original_value & 1) && type == PCI_BAR_TYPE_MEM)
        {
            bar->iobase = original_value & PCI_BAR_MEM_MASK;
            bar->size = pci_size(updated_value, PCI_BAR_MEM_MASK);
            return EOK;
        }
    }
    return -EIO;
}
```
```c
// 设置 DMA
static void ide_setup_dma(ide_ctrl_t *ctrl, int cmd, char *buf, u32 len)
{
    // 保证没有跨页 虚拟地址连续不代表物理地址连续
    assert(((u32)buf + len) <= ((u32)buf & (~0xfff)) + PAGE_SIZE);

    // 设置 prdt
    ctrl->prd.addr = get_paddr((u32)buf);
    ctrl->prd.len = len | IDE_LAST_PRD;

    // 设置 prd 地址
    outl(ctrl->bmbase + BM_PRD_ADDR, (u32)&ctrl->prd);

    // 设置读写
    outb(ctrl->bmbase + BM_COMMAND_REG, cmd | BM_CR_STOP);

    // 设置中断和错误
    outb(ctrl->bmbase + BM_STATUS_REG, inb(ctrl->bmbase + BM_STATUS_REG) | BM_SR_INT | BM_SR_ERR);
}

// 启动 DMA
static void ide_start_dma(ide_ctrl_t *ctrl)
{
    outb(ctrl->bmbase + BM_COMMAND_REG, inb(ctrl->bmbase + BM_COMMAND_REG) | BM_CR_START);
}

err_t ide_udma_read(ide_disk_t *disk, void *buf, u8 count, idx_t lba)
{
    LOGK("IDE dma read lba 0x%x\n", lba);

    int ret = 0;
    ide_ctrl_t *ctrl = disk->ctrl;

    lock_acquire(&ctrl->lock);

    // 设置 DMA
    ide_setup_dma(ctrl, BM_CR_READ, buf, count * SECTOR_SIZE);

    // 选择扇区
    ide_select_sector(disk, lba, count);

    // 设置 UDMA 读
    outb(disk->ctrl->iobase + IDE_COMMAND, IDE_CMD_READ_UDMA);

    // 启动总线的 DMA
    ide_start_dma(ctrl);

    // 阻塞
    disk->ctrl->waiter = running_task();
    if ((ret = task_block(disk->ctrl->waiter, NULL, TASK_BLOCKED, IDE_TIMEOUT)) < EOK)
    {
        LOGK("ide dma error occur!!! %d\n", ret);
    }

    assert(ide_stop_dma(ctrl) == EOK);

    lock_release(&ctrl->lock);
    return ret;
}

err_t ide_udma_write(ide_disk_t *disk, void *buf, u8 count, idx_t lba)
{
    LOGK("IDE dma write lba 0x%x\n", lba);
    int ret = EOK;
    ide_ctrl_t *ctrl = disk->ctrl;

    lock_acquire(&ctrl->lock);

    // 设置 DMA 主控写磁盘
    ide_setup_dma(ctrl, BM_CR_WRITE, buf, count * SECTOR_SIZE);

    // 选择扇区
    ide_select_sector(disk, lba, count);

    // 设置 UDMA 写
    outb(disk->ctrl->iobase + IDE_COMMAND, IDE_CMD_WRITE_UDMA);
    
    // 启动总线的 DMA
    ide_start_dma(ctrl);

    // 阻塞
    disk->ctrl->waiter = running_task();
    if ((ret = task_block(disk->ctrl->waiter, NULL, TASK_BLOCKED, IDE_TIMEOUT)) < EOK)
    {
        LOGK("ide dma error occur!!! %d\n", ret);
    }

    assert(ide_stop_dma(ctrl) == EOK);

    lock_release(&ctrl->lock);
    return ret;
}
```


## 参考文献

- <https://wiki.osdev.org/ATA/ATAPI_using_DMA>


---


# 22.e1000 网卡驱动

## 接收数据

### 接收地址寄存器

编程接收地址寄存器 (RAL/RAH) 以设置期望的以太网地址，使用 RAL[0]/RAH[0] 存储单个以太网 MAC 地址。
初始化组播表数组 MTA 为 0b，软件可按需添加条目。

### 中断掩码寄存器

设置/读取中断掩码寄存器 (IMS)，以在事件发生时触发中断。
推荐启用的位包括 RXT、RXO、RXDMT、RXSEQ 和 LSC。

### RX 描述符内存

为接收描述符列表分配内存，确保其在段边界上对齐。
设置接收描述符基址 (RDBAL/RDBAH) 和长度 (RDLEN) 寄存器。

### RX 描述符索引

初始化接收描述符头 (RDH) 和尾 (RDT) 寄存器，头指向第一个有效描述符，尾指向最后一个描述符之后。

### 接收控制寄存器

编程接收控制 (RCTL) 寄存器，设置 RCTL.EN 启用接收器。
设置 RCTL.LPE 以支持处理大于标准大小的数据包（如巨型帧）。
配置 RCTL.BAM 接收广播包，RCTL.BSIZE 配置缓冲区大小，并设置 RCTL.SECRC 剥离以太网 CRC。


## 发送数据

为传输描述符列表分配内存，并确保其在段边界上对齐。
设置传输描述符基址 (TDBAL/TDBAH) 和长度 (TDLEN) 寄存器。
初始化传输控制寄存器 (TCTL) 以启用发送，并配置碰撞阈值和距离等参数。


## qemu

qemu 配置需要加入选项：
```makefile
QEMU+= -netdev tap,id=eth0,ifname=tap0,script=no,downscript=no # 网络设备
QEMU+= -device e1000,netdev=eth0,mac=5A:5A:5A:5A:5A:33 # 网卡 e1000
```


## vmware

VMWare 默认网卡是 e1000。


## bochs

bochs 首先需要开启编译选项 `--enable-e1000`，未经测试；


## 相关定义

- 供应商英特尔
  #define VENDORID 0x8086

- 8254x 兼容网卡
  #define DEVICEID_LOW 0x1000
  #define DEVICEID_HIGH 0x1028

```c
// 寄存器偏移
enum REGISTERS
{
    E1000_CTRL = 0x00,   // Device Control 设备控制
    E1000_STATUS = 0x08, // Device Status 设备状态
    E1000_EERD = 0x14,   // EEPROM Read EEPROM 读取

    E1000_ICR = 0xC0, // Interrupt Cause Read 中断原因读
    E1000_ITR = 0xC4, // Interrupt Throttling 中断节流
    E1000_ICS = 0xC8, // Interrupt Cause Set 中断原因设置
    E1000_IMS = 0xD0, // Interrupt Mask Set/Read 中断掩码设置/读
    E1000_IMC = 0xD8, // Interrupt Mask Clear 中断掩码清除

    E1000_RCTL = 0x100,   // Receive Control 接收控制
    E1000_RDBAL = 0x2800, // Receive Descriptor Base Address LOW 接收描述符低地址
    E1000_RDBAH = 0x2804, // Receive Descriptor Base Address HIGH 64bit only 接收描述符高地址
    E1000_RDLEN = 0x2808, // Receive Descriptor Length 接收描述符长度
    E1000_RDH = 0x2810,   // Receive Descriptor Head 接收描述符头
    E1000_RDT = 0x2818,   // Receive Descriptor Tail 接收描述符尾

    E1000_TCTL = 0x400,   // Transmit Control 发送控制
    E1000_TDBAL = 0x3800, // Transmit Descriptor Base Low 传输描述符低地址
    E1000_TDBAH = 0x3804, // Transmit Descriptor Base High 传输描述符高地址
    E1000_TDLEN = 0x3808, // Transmit Descriptor Length 传输描述符长度
    E1000_TDH = 0x3810,   // TDH Transmit Descriptor Head 传输描述符头
    E1000_TDT = 0x3818,   // TDT Transmit Descriptor Tail 传输描述符尾

    E1000_MAT0 = 0x5200, // Multicast Table Array 05200h-053FCh 组播表数组
    E1000_MAT1 = 0x5400, // Multicast Table Array 05200h-053FCh 组播表数组
};
```

```c
// 主机字节序到网络字节序
#define htonl(l) ((((l)&0xFF) << 24) | (((l)&0xFF00) << 8) | (((l)&0xFF0000) >> 8) | (((l)&0xFF000000) >> 24))
#define htons(s) ((((s)&0xFF) << 8) | (((s)&0xFF00)

// 网络字节序到主机字节序
#define ntohl(l) htonl((l))
#define ntohs(s) htons((s))

#define NET_TIMEOUT 5000

#define ETH_MTU 1518
#define IP_MTU 1500

#define ETH_ADDR_LEN 6
#define IP_ADDR_LEN 4

typedef u8 eth_addr_t[ETH_ADDR_LEN]; // MAC 地址
typedef u8 ip_addr_t[IP_ADDR_LEN];   // IPV4 地址

typedef struct netif_t netif_t;
typedef struct pbuf_t pbuf_t;
```


## 数据结构

```c
// 以太网帧
typedef struct eth_t
{
    eth_addr_t dst; // 目标地址
    eth_addr_t src; // 源地址
    u16 type;       // 类型
    union
    {
        u8 payload[0]; // 载荷
        arp_t arp[0];  // arp 包
        ip_t ip[0];    // ip 包
    };

} _packed eth_t;
```
```c
// 接收描述符
typedef struct rx_desc_t
{
    u64 addr;     // 地址
    u16 length;   // 长度
    u16 checksum; // 校验和
    u8 status;    // 状态
    u8 error;     // 错误
    u16 special;  // 特殊
} _packed rx_desc_t;

// 传输描述符
typedef struct tx_desc_t
{
    u64 addr;    // 缓冲区地址
    u16 length;  // 包长度
    u8 cso;      // Checksum Offset
    u8 cmd;      // 命令
    u8 status;   // 状态
    u8 css;      // Checksum Start Field
    u16 special; // 特殊
} _packed tx_desc_t;

typedef struct e1000_t
{
    char name[NAME_LEN]; // 名称

    pci_device_t *device; // PCI 设备
    u32 membase;          // 映射内存基地址

    u8 mac[6];   // MAC 地址
    bool link;   // 网络连接状态
    bool eeprom; // 只读存储器可用

    rx_desc_t *rx_desc; // 接收描述符
    u16 rx_cur;         // 接收描述符指针

    tx_desc_t *tx_desc; // 传输描述符
    u16 tx_cur;         // 传输描述符指针
    task_t *tx_waiter;  // 传输等待进程

    pbuf_t **rx_pbuf; // 接收高速缓冲数组
    pbuf_t **tx_pbuf; // 传输高速缓冲数组

    netif_t *netif; // 虚拟网卡
} e1000_t;
```


## 相关函数

```c
// 映射内存 IO
// 内存输入字节 8bit
u8 minb(u32 addr)
{
    return *((volatile u8 *)addr);
}
// 内存输入字 16bit
u16 minw(u32 addr)
{
    return *((volatile u16 *)addr);
}
// 内存输入双字 32bit
u32 minl(u32 addr)
{
    return *((volatile u32 *)addr);
}
// 内存输出字节
void moutb(u32 addr, u8 value)
{
    *((volatile u8 *)addr) = value;
}
// 内存输出字
void moutw(u32 addr, u16 value)
{
    *((volatile u16 *)addr) = value;
}
// 内存输出双字
void moutl(u32 addr, u32 value)
{
    *((volatile u32 *)addr) = value;
}
```
```c
// 接收数据包
static void recv_packet(e1000_t *e1000)

// 发送数据包
static void send_packet(netif_t *netif, pbuf_t *pbuf)

// 中断处理函数
static void e1000_handler(int vector)

// 检测只读存储器
static void e1000_eeprom_detect(e1000_t *e1000)

// 读取只读存储器
static u16 e1000_eeprom_read(e1000_t *e1000, u8 addr)

// 读取 MAC 地址
static void e1000_read_mac(e1000_t *e1000)

// 重置网卡
static void e1000_reset(e1000_t *e1000)

// 查找网卡设备
static pci_device_t *find_e1000_device()
{
    pci_device_t *device = NULL;

    for (size_t i = DEVICEID_LOW; i <= DEVICEID_HIGH; i++) // 1000 ~ 1028
    {
        device = pci_find_device(VENDORID, i); // VENDORID：因特尔
        if (device)
            break;
    }
    return device;
}

// 初始化 e1000
void e1000_init()
{
    pci_device_t *device = find_e1000_device();
    if (!device)
    {
        LOGK("PCI e1000 ethernet card not exists...\n");
        return;
    }

    e1000_t *e1000 = &obj;
    e1000->tx_waiter = NULL;

    strcpy(e1000->name, "e1000");

    e1000->device = device;

    pci_enable_busmastering(device);

    pci_bar_t membar;
    err_t ret = pci_find_bar(device, &membar, PCI_BAR_TYPE_MEM);
    assert(ret == EOK);

    LOGK("e1000 membase 0x%x size 0x%x\n", membar.iobase, membar.size);

    // 映射内存因该在高地址，避免与用户程序地址和操作系统冲突
    // 但是不在最后 4M 内，最后 4M 用于页表
    // 不然内存映射机制有问题，需要调整，不能直接使用 map_area
    assert(membar.iobase < 0xFFC00000 && membar.iobase >= 0xF0000000);

    // 映射物理内存区域
    e1000->membase = membar.iobase;
    map_area(membar.iobase, membar.size);

    e1000_reset(e1000);

    e1000->netif = netif_setup(e1000, e1000->mac, send_packet);

    u32 intr = pci_interrupt(device);

    LOGK("e1000 irq 0x%X...\n", intr);
    assert(intr == IRQ_NIC);

    // 设置中断处理函数
    set_interrupt_handler(intr, e1000_handler);
    set_interrupt_mask(intr, true);
    if (intr >= 8)
        set_interrupt_mask(IRQ_CASCADE, true);
}
```


## 参考文献

- <https://wiki.osdev.org/Networking>
- <https://pdos.csail.mit.edu/6.828/2018/readings/hardware/8254x_GBe_SDM.pdf>
- <https://wiki.osdev.org/Intel_Ethernet_i217>
- <https://github.com/klange/toaruos>
- <https://www.qemu.org/docs/master/system/qemu-manpage.html>
- <http://www.sanbarrow.com/vmx/vmx-network-advanced.html>
- <https://bochs.sourceforge.io/doc/docbook/user/bochsrc.html>
- <https://forum.osdev.org/viewtopic.php?f=1&t=15811>
- <https://wiki.osdev.org/PIC#Spurious IRQs>


---



# 23.ATAPI 光盘驱动

ATAPI 是指使用 ATA6(或更高) 标准命令集的包接口(Packet Interface) 的设备。


## 检测

根据 ATA/ATAPI 规范（T13 1410D rev 3b），可以通过 sector count 和 LBA Low, Mid, High 寄存器中的签名来检测设备类型（寄存器地址 0x1F2-0x1F5）。
- 签名为 0x01, 0x01, 0x00, 0x00 表示非包设备，使用 IDENTIFY DEVICE (0xEC) 检测。
- 签名为 0x01, 0x01, 0x14, 0xEB 表示包设备，使用 IDENTIFY PACKET DEVICE (0xA1) 检测。

签名会在设备上电、复位或接收 EXECUTE DEVICE DIAGNOSTIC 命令时被重置。


## PACKET 命令 0xA0

每个 ATAPI 命令由一个命令字节（来自 SCSI 命令集）和 11 个数据字节组成。例如，读取目录的命令：
```c++
uint8_t atapi_readtoc[]=  { 0x43 /* ATAPI_READTOC */, 0, 1, 0, 0, 0, 0, 0, 12, 0x40, 0, 0};
```
`ATA PACKET` 命令在 PIO 模式下分三个阶段：
1. 设置 ATA IO 端口寄存器，并发送 ATA PACKET 命令：
   ```c++
    outb(ATA Command Register, 0xA0);
   ```
2. 当设备准备好后（BSY 清除，DRQ 设置），将 ATAPI 命令字符串通过 PIO 传输发送到设备。
3. 等待中断 IRQ，读取 LBA Mid 和 LBA High 寄存器，传输相应字节数，循环等待下一个 IRQ。

在 DMA 模式下，第三阶段由设备通过 PCI 控制器自动处理。


## IDENTIFY PACKET DEVICE 命令 0xA1

此命令类似于 IDENTIFY DEVICE，用于返回 ATAPI 设备的信息，以标准 ATA PIO 模式执行。


## 光盘内容

光盘内容由 SCSI MMC 规范管理，结构为会话和轨道。可读实体为逻辑磁道，有些介质支持多会话多轨道，有些仅支持单轨道单会话。


## x86 方向

需要一个缓冲区：
- 若为 DMA 缓冲区，需遵循 PRD 规则（参见 ATA/ATAPI 文章）。
- 若为 PIO 缓冲区，需知道其大小 maxByteCount，它必须为无符号字，0 是非法的。

选择目标设备通过在设备选择寄存器中设置主/从位完成。
```c++
outb(0x1F6, slavebit<<4);
```
如果该命令将使用 DMA，则将 Features Register 设置为 1，否则为 PIO 设置为 0。
```c++
outb(0x1F1, isDMA);
```
扇区计数寄存器和 LBA 低寄存器目前未使用。在 LBA 中寄存器和 LBA 高寄存器中发送 maxByteCount。
```c++
outb(0x1F4, (maxByteCount & 0xff));
outb(0x1F5, (maxByteCount >> 8));
```
将 `ATAPI PACKET` 命令发送到命令寄存器
```c++
outb(0x1F7, 0xA0);
```
等待 IRQ 或轮询 BSY 清除和 DRQ 设置。然后将 ATAPI 命令作为 6 个字发送到数据端口。
```c++
outw(0x1F0, Command1);
outw(0x1F0, Command2);
outw(0x1F0, Command3);
outw(0x1F0, Command4);
outw(0x1F0, Command5);
outw(0x1F0, Command6);
```
然后等待另一个IRQ。不能轮询。
如果这是一个 DMA 命令(isDMA == 1)，那么就完成了。当 IRQ 到达时，传输就完成了。如果它是一个 PIO 命令，当 IRQ 到达时，读取 LBA 中寄存器和LBA 高寄存器。一旦有了传输大小 (bytecount = LBA High << 8 | LBA Mid)，进行 PIO 传输。
```c++
wordcount = bytecount/2;
```
循环 `inw(0x1F0)` 或 `outw(0x1F0)` 字数次数。
如果传输完成，`BSY` 和 `DRQ` 将被清除。否则，等待下一个 IRQ，再读或写相同数量的单词。


## 完整命令集

| SCSI 命令                                         | 命令码      |
| ------------------------------------------------- | ----------- |
| TEST UNIT READY                                   | 0x00        |
| REQUEST SENSE                                     | 0x03        |
| FORMAT UNIT                                       | 0x04        |
| INQUIRY                                           | 0x12        |
| START STOP UNIT (Eject device)                    | 0x1B        |
| PREVENT ALLOW MEDIUM REMOVAL                      | 0x1E        |
| READ FORMAT CAPACITIES                            | 0x23        |
| READ CAPACITY                                     | 0x25        |
| READ (10)                                         | 0x28        |
| WRITE (10)                                        | 0x2A        |
| SEEK (10)                                         | 0x2B        |
| WRITE AND VERIFY (10)                             | 0x2E        |
| VERIFY (10)                                       | 0x2F        |
| SYNCHRONIZE CACHE                                 | 0x35        |
| WRITE BUFFER                                      | 0x3B        |
| READ BUFFER                                       | 0x3C        |
| READ TOC/PMA/ATIP                                 | 0x43        |
| GET CONFIGURATION                                 | 0x46        |
| GET EVENT STATUS NOTIFICATION                     | 0x4A        |
| READ DISC INFORMATION                             | 0x51        |
| READ TRACK INFORMATION                            | 0x52        |
| RESERVE TRACK                                     | 0x53        |
| SEND OPC INFORMATION                              | 0x54        |
| MODE SELECT (10)                                  | 0x55        |
| REPAIR TRACK                                      | 0x58        |
| MODE SENSE (10)                                   | 0x5A        |
| CLOSE TRACK SESSION                               | 0x5B        |
| READ BUFFER CAPACITY                              | 0x5C        |
| SEND CUE SHEET                                    | 0x5D        |
| REPORT LUNS                                       | 0xA0        |
| BLANK                                             | 0xA1        |
| SECURITY PROTOCOL IN                              | 0xA2        |
| SEND KEY                                          | 0xA3        |
| REPORT KEY                                        | 0xA4        |
| LOAD/UNLOAD MEDIUM                                | 0xA6        |
| SET READ AHEAD                                    | 0xA7        |
| READ (12)                                         | 0xA8        |
| WRITE (12)                                        | 0xAA        |
| READ MEDIA SERIAL NUMBER / SERVICE ACTION IN (12) | 0xAB / 0x01 |
| GET PERFORMANCE                                   | 0xAC        |
| READ DISC STRUCTURE                               | 0xAD        |
| SECURITY PROTOCOL OUT                             | 0xB5        |
| SET STREAMING                                     | 0xB6        |
| READ CD MSF                                       | 0xB9        |
| SET CD SPEED                                      | 0xBB        |
| MECHANISM STATUS                                  | 0xBD        |
| READ CD                                           | 0xBE        |
| SEND DISC STRUCTURE                               | 0xBF        |


## 相关定义

- 扇区大小：#define SECTOR_SIZE 512
- 光盘扇区大小：#define CD_SECTOR_SIZE 2048


## 数据结构

```c
// IDE 磁盘
typedef struct ide_disk_t
{
    char name[8];                  // 磁盘名称
    struct ide_ctrl_t *ctrl;       // 控制器指针
    u8 selector;                   // 磁盘选择
    bool master;                   // 主盘
    u32 total_lba;                 // 可用扇区数量
    u32 cylinders;                 // 柱面数
    u32 heads;                     // 磁头数
    u32 sectors;                   // 扇区数
    u32 interface;                 // 磁盘类型
    u32 sector_size;               // 扇区大小
    ide_part_t parts[IDE_PART_NR]; // 硬盘分区
} ide_disk_t;
```


## 相关函数

```c
ide_install()
```
函数中
```c
else if (disk->interface == IDE_INTERFACE_ATAPI)
{
   device_install(
      DEV_BLOCK, DEV_IDE_CD, disk, disk->name, 0,
      ide_pio_ioctl, ide_atapi_read, NULL);
}
```
---
```c
ide_ctrl_init()
```
函数中
```c
else if (disk->interface == IDE_INTERFACE_ATAPI)
{
   LOGK("Disk %s interface is ATAPI\n", disk->name);
   disk->sector_size = CD_SECTOR_SIZE; // size
   if (ide_identify(disk, buf) == EOK)
   {
      disk->total_lba = ide_atapi_read_capacity(disk); // 获得光盘容量
      LOGK("disk %s total lba %d\n", disk->name,disk->total_lba);
   }
}
```
---
```c
ide_identify(ide_disk_t *disk, u16 *buf)
```
函数中
```c
// ide_select_sector(disk, 0, 0);
u8 cmd = IDE_CMD_IDENTIFY;
if (disk->interface == IDE_INTERFACE_ATAPI)
{
   cmd = IDE_CMD_PIDENTIFY; // 光盘 PACKET 命令
}
outb(disk->ctrl->iobase + IDE_COMMAND, cmd);
int ret = EOF;
```
以及
```c
if (disk->interface == IDE_INTERFACE_ATAPI) // 直接结束，否则识别lba
{
   ret = EOK;
   goto rollback;
}
```
---
```c
// 读取 ATAPI 数据包
static int ide_atapi_packet_read_pio(ide_disk_t *disk, u8 *packet, int packet_length, void *buffer, size_t buffer_size)
{
    // 等待磁盘准备好
    // ide_busy_wait(disk->ctrl, IDE_SR_NULL);

    lock_acquire(&disk->ctrl->lock);

    // 配置寄存器
    outb(disk->ctrl->iobase + IDE_FEATURE, IDE_ATAPI_FEATURE_PIO);
    outb(disk->ctrl->iobase + IDE_SECTOR, 0);
    outb(disk->ctrl->iobase + IDE_LBA_LOW, 0);
    outb(disk->ctrl->iobase + IDE_LBA_MID, (buffer_size & 0xFF));
    outb(disk->ctrl->iobase + IDE_LBA_HIGH, (buffer_size >> 8) & 0xFF);
    outb(disk->ctrl->iobase + IDE_HDDEVSEL, disk->selector & 0x10);

    // 发送 ATAPI 命令
    outb(disk->ctrl->iobase + IDE_COMMAND, IDE_CMD_PACKET);

    int ret = EOF;
    // 等待设备准备好
    if ((ret = ide_busy_wait(disk->ctrl, IDE_SR_DRDY, IDE_TIMEOUT)) < 0)
        goto exit;

    // 写入 packet 内容
    u16 *packet_ptr = (u16 *)packet;
    for (size_t i = 0; i < packet_length / 2; i++)
    {
        outw(disk->ctrl->iobase + IDE_DATA, packet_ptr[i]);
    }

    // 阻塞等待磁盘完成数据写入
    task_t *current_task = running_task();
    disk->ctrl->waiter = current_task;
    if ((ret = task_block(current_task, NULL, TASK_BLOCKED, IDE_TIMEOUT)) < 0)
        goto exit;

    int remaining_size = buffer_size;

    packet_ptr = (u16 *)buffer;
    int buffer_index = 0;
    while (remaining_size > 0)
    {
        // 等待磁盘准备好
        if ((ret = ide_busy_wait(disk->ctrl, IDE_SR_NULL, IDE_TIMEOUT)) < 0)
            goto exit;

        // 读取可用字节数
        int byte_count = inb(disk->ctrl->iobase + IDE_LBA_HIGH) << 8;
        byte_count |= inb(disk->ctrl->iobase + IDE_LBA_MID);

        assert(byte_count >= 0);

        if (byte_count == 0)
            break;
        assert(remaining_size <= byte_count);
        // 读取字节数据
        for (size_t i = 0; i < byte_count / 2; i++)
        {
            packet_ptr[buffer_index++] = inw(disk->ctrl->iobase + IDE_DATA);
        }
        remaining_size -= byte_count;
    }
    ret = buffer_size - remaining_size;

exit:
    lock_release(&disk->ctrl->lock);
    return ret;
}


sstatic int ide_atapi_packet_read_dma(ide_disk_t *disk, u8 *pkt, int pktlen, void *buf, size_t bufsize)
{
    // 等待磁盘空闲
    // ide_busy_wait(disk->ctrl, IDE_SR_NULL);

    // 加锁以保证线程安全
    lock_acquire(&disk->ctrl->lock);

    // 初始化 DMA 设置
    ide_setup_dma(disk->ctrl, BM_CR_READ, buf, bufsize);

    // 配置必要的寄存器
    outb(disk->ctrl->iobase + IDE_FEATURE, IDE_ATAPI_FEATURE_DMA);
    outb(disk->ctrl->iobase + IDE_SECTOR, 0);
    outb(disk->ctrl->iobase + IDE_LBA_LOW, 0);
    outb(disk->ctrl->iobase + IDE_LBA_MID, 0);
    outb(disk->ctrl->iobase + IDE_LBA_HIGH, 0);
    outb(disk->ctrl->iobase + IDE_HDDEVSEL, disk->selector & 0x10);

    // 发出 ATAPI 命令
    outb(disk->ctrl->iobase + IDE_COMMAND, IDE_CMD_PACKET);

    int result = EOF;
    // 检查磁盘状态，确保设备就绪
    if ((result = ide_busy_wait(disk->ctrl, IDE_SR_DRDY, IDE_TIMEOUT)) < 0)
        goto error;

    // 将包数据写入数据寄存器
    u16 *data = (u16 *)pkt;
    for (size_t i = 0; i < pktlen / 2; i++)
    {
        outw(disk->ctrl->iobase + IDE_DATA, data[i]);
    }

    // 启动 DMA 操作
    ide_start_dma(disk->ctrl);

    // 等待 DMA 操作完成
    task_t *task = running_task();
    disk->ctrl->waiter = task;
    if ((result = task_block(task, NULL, TASK_BLOCKED, IDE_TIMEOUT)) < 0)
        goto error;

    // 确保 DMA 正常停止并无错误
    assert(ide_stop_dma(disk->ctrl) == EOK);
    result = bufsize;

error:
    // 释放锁
    lock_release(&disk->ctrl->lock);
    return result;
}

// 读取 ATAPI 容量
static int ide_atapi_read_capacity(ide_disk_t *disk)
{
    u8 packet[12];
    u32 buffer[2];
    u32 block_count;
    u32 block_size;

    memset(packet, 0, sizeof(packet));
    packet[0] = IDE_ATAPI_CMD_READCAPICITY;

    // 根据控制器类型选择读取函数
    int (*read_func)() = ide_atapi_packet_read_pio;
    if (disk->ctrl->iotype == IDE_TYPE_UDMA)
        read_func = ide_atapi_packet_read_dma;

    int result = read_func(disk, packet, sizeof(packet), buffer, sizeof(buffer));
    if (result < 0)
        return result;
    if (result != sizeof(buffer))
        return -EIO;

    block_count = ntohl(buffer[0]);
    block_size = ntohl(buffer[1]);

    if (block_size != disk->sector_size)
    {
        LOGK("CD block size warning %d\n", block_size);
        return 0;
    }
    return block_count;
}

// ATAPI 设备读
static int ide_atapi_read(ide_disk_t *disk, void *buf, int count, idx_t lba)
{
    u8 packet[12];
    if (count > 0xffff)
        return -EIO;

    memset(packet, 0, sizeof(packet));

    packet[0] = IDE_ATAPI_CMD_READ10;
    packet[2] = lba >> 24;
    packet[3] = (lba >> 16) & 0xFF;
    packet[4] = (lba >> 8) & 0xFF;
    packet[5] = lba & 0xFF;
    packet[7] = (count >> 8) & 0xFF;
    packet[8] = count & 0xFF;

    int (*read_func)() = ide_atapi_packet_read_pio;
    if (disk->ctrl->iotype == IDE_TYPE_UDMA)
        read_func = ide_atapi_packet_read_dma;

    return read_func(disk, packet, sizeof(packet), buf, count * disk->sector_size);
}
```


## 参考文献

- <https://wiki.osdev.org/ATAPI>


---